## 关系数据库
关系数据库（Relational Database）是一种基于关系模型的数据库，它通过表格的形式存储数据，每个表格由行（记录）和列（字段）组成。关系数据库管理系统（RDBMS）是管理这种数据库的软件，它允许用户创建、查询、更新和管理数据。以下是关系数据库的一些关键概念和特性：

1. **表（Table）**：关系数据库中存储数据的基本结构，每个表由行和列组成。
    
2. **行（Row）**：表中的单个记录，每行包含一组相关的数据。
    
3. **列（Column）**：表中的一个字段，所有行的同一列存储相同类型的数据。
    
4. **主键（Primary Key）**：表中用于唯一标识每条记录的字段或字段组合。
    
5. **外键（Foreign Key）**：一个表中的字段，它指向另一个表的主键，用于建立两个表之间的关系。
    
6. **关系（Relationship）**：表之间的联系，如一对一、一对多或多对多。
    
7. **规范化（Normalization）**：一种设计技术，用于减少数据冗余和依赖，提高数据完整性。
    
8. **事务（Transaction）**：一组不可分割的操作序列，要么全部成功，要么全部失败。
    
9. **ACID属性**：事务的四个关键属性，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）。
    
10. **SQL（Structured Query Language）**：一种用于管理关系数据库的标准编程语言，用于查询、更新和管理数据。
    
11. **视图（View）**：一个虚拟表，其内容由SQL查询定义，可以简化复杂的查询操作。
    
12. **索引（Index）**：一种数据库对象，用于提高数据检索效率。
    
13. **存储过程（Stored Procedure）**：一组为了执行特定任务而预编译的SQL语句，可以提高性能并减少网络流量。
    

关系数据库广泛应用于各种领域，如金融、医疗、教育和电子商务等，因为它们提供了一种结构化和可靠的数据存储解决方案。常见的关系数据库管理系统包括MySQL、PostgreSQL、Oracle、SQL Server和SQLite等。
### 关系数据模型
关系数据模型（Relational Data Model）是一种数据模型，它基于关系的概念来组织和管理数据。这种模型由数学家埃德加·科德（Edgar F. Codd）在1970年提出，它的核心思想是将复杂的数据结构简化为简单的二维表格形式，每个表格称为一个关系。
1. **静态的数据结构描述**：
    
    - 这是指数据库中数据的组织方式和结构。在关系数据模型中，数据被组织成一系列的表（或称为关系），每个表由行（或称为元组）和列（或称为属性）组成。
    - **行**：表中的每行代表一个数据记录，是数据的最小单位。
    - **列**：表中的每列代表一个属性，所有行的同一列具有相同的数据类型。
    - **表**：表是数据的基本存储单位，它定义了数据的静态结构，包括哪些列、列的数据类型、列之间的关系等。
    - **模式（Schema）**：定义了数据库的结构，包括表的结构、表之间的关系、视图、索引等。


1. **动态的数据操作集合**：
    
    - 这是指对数据库中数据进行操作的一系列指令集合，通常通过SQL（Structured Query Language）实现。
    - **查询（Query）**：检索数据，如SELECT语句。
    - **插入（Insert）**：添加新数据，如INSERT语句。
    - **更新（Update）**：修改现有数据，如UPDATE语句。
    - **删除（Delete）**：移除数据，如DELETE语句。
    - 这些操作允许用户动态地与数据库交互，执行数据的增删改查等操作。

1. **数据完整性约束**：
    
    - 这是指确保数据库中数据准确性和一致性的一系列规则。
    - **实体完整性**：确保每个表都有一个主键，且主键的值是唯一的。
    - **参照完整性**：确保外键的值必须在关联表的主键中存在，或者为NULL（如果允许）。
    - **域完整性**：确保列中的数据满足特定的条件，如数据类型、长度限制等。
    - **用户定义的完整性**：根据应用需求定义的额外规则，如年龄必须大于0，或者某个字段的值必须符合特定的格式。
    - 数据完整性约束确保数据在插入、更新和删除时保持一致性和准确性，避免数据冗余和错误。

### 关系数据库逻辑设计
**关系数据库的逻辑设计是数据库设计过程中的一个关键阶段，它涉及到确定数据库中需要存储的数据以及这些数据如何组织以满足应用需求。以下是逻辑设计的步骤和工具，以及规范化理论的详细介绍**
#### 针对一个具体问题，应如何构造一个适合于它的数据模式，即应该构造几个关系，每个关系由哪些属性组成等。
1. **需求分析**：
    
    - 与业务专家沟通，了解业务流程、数据需求和用户需求。
    - 确定需要存储哪些数据以及这些数据如何被使用。
2. **概念模型构建**：
    
    - 使用实体-关系模型（ER Model）来表示业务实体、属性和关系。
    - 绘制ER图，标识出实体、属性和实体之间的关系。
3. **实体识别**：
    
    - 确定哪些实体需要在数据库中表示，例如客户、订单、产品等。
4. **属性定义**：
    
    - 确定每个实体的属性，这些属性是描述实体的详细信息，例如客户的姓名、地址，订单的订单号、日期等。
5. **关系确定**：
    
    - 确定实体之间的关系，如一对多（一个客户可以有多个订单）、多对一（一个订单只能属于一个客户）等。
6. **转换为关系模型**：
    
    - 将ER图转换为关系模型，每个实体通常对应一个表，每个关系对应表之间的外键关联。
7. **确定主键和外键**：
    
    - 为每个表确定一个主键，用于唯一标识表中的每条记录。
    - 定义外键以表示实体之间的关系，确保参照完整性。
8. **规范化**：
    
    - 应用规范化理论（如1NF、2NF、3NF等）来优化关系模式，减少数据冗余和依赖。
9. **定义视图和索引**：
    
    - 根据需要创建视图以简化复杂的查询和保护数据。
    - 定义索引以提高查询性能。
10. **数据完整性约束**：
    
    - 定义数据完整性约束，包括实体完整性、参照完整性、域完整性和用户定义的完整性。
11. **性能考虑**：
    
    - 考虑查询性能，可能通过创建适当的索引和选择合理的数据类型来优化。
12. **文档化**：
    
    - 记录数据模式的设计，包括表结构、关系和约束，以便维护和未来的扩展。
**示例：**

假设我们需要为一个在线书店设计数据库模式：

1. **实体**：
    
    - 客户（Customer）
    - 书籍（Book）
    - 订单（Order）
    - 订单详情（OrderDetail）
2. **属性**：
    
    - 客户：客户ID、姓名、地址、邮箱等。
    - 书籍：书籍ID、标题、作者、价格、库存等。
    - 订单：订单ID、客户ID、订单日期等。
    - 订单详情：订单详情ID、订单ID、书籍ID、数量、单价等。
3. **关系**：
    
    - 客户与订单：一对多（一个客户可以有多个订单）。
    - 书籍与订单详情：多对多（一本书可以出现在多个订单中，一个订单可以包含多本书）。
4. **主键和外键**：
    
    - 客户表的主键是客户ID。
    - 书籍表的主键是书籍ID。
    - 订单表的主键是订单ID，外键是客户ID。
    - 订单详情表的主键是订单详情ID，外键是订单ID和书籍ID。
#### 数据库逻辑设计的工具──关系数据库的规范化理论
关系数据库的规范化理论是数据库设计中用于减少数据冗余和提高数据一致性的过程。它通过分解关系模式来实现，确保数据库结构满足一定的规范条件。以下是关系数据库规范化理论的详细介绍：

##### 1. 规范化的目的和基本思想
- **目的**：通过分解低级别范式的关系模式，转换为高级别范式的关系模式集合，以减少数据冗余和更新异常。
- **基本思想**：确保每个关系模式只描述一个概念、实体或实体间的一种联系，实现概念的单一化，并逐步消除不合适的数据依赖部分，使各关系模式分离。

##### 2. 规范化程度的选择
- **平衡原则**：在数据变动不频繁的数据库中，规范化程度可以稍低，以提高查询效率。
- **程度选择**：通常达到大多数关系模式为第三范式（3NF）即可。
- **考虑因素**：权衡存取效率与数据冗余、一致性等因素，根据具体应用场景选择适当的规范化程度。

##### 3. 规范化过程的关键原则
- **无损连接分解**：确保分解过程中数据不会丢失或增加，保持数据的完整性。
- **保持函数依赖**：分解后的关系模式应保持原关系模式中的函数依赖，避免引入更新异常。

##### 4. 分解的实现
- **分解方法**：将一个关系模式分解为多个子模式，每个子模式应有更少的属性，即更高的范式级别。
- **考虑因素**：存储空间的优化与数据一致性，查询效率，考虑连接运算的代价。
- **正确性与可实现性**：确保分解后的模式既正确又实用，考虑实际应用中的数据处理和查询需求。

##### 5. 规范化理论的实际应用
在实际应用中，规范化过程并不总是严格按照理论进行。实际应用中的规范化考虑了多种因素，包括数据依赖关系的识别难度、数据的动态特征、以及从实体-关系模型（E-R模型）到关系模式的转换等。

##### 6. 数据依赖关系的识别
在实践中，识别所有的数据依赖（函数依赖和多值依赖）是一项挑战性的任务。如果数据依赖识别不完整或错误，可能导致不理想的数据库设计。

##### 7. 动态数据特征的考虑
关系模式的规范化应考虑数据的动态特征，比如数据更新的频率。对于经常更新的数据，高度的规范化可能不适宜，因为它可能导致频繁的连接操作，影响性能。

##### 8. E-R模型到关系模式的转换
在实际应用中，数据库设计通常首先从现实环境建立E-R模型，然后将其转换为关系数据库模式。E-R模型通常会产生较小的关系模式（属性较少），这可能需要合并而不是分解关系模式。

##### 9. 查询方便性与合并关系模式
为了方便数据库查询，有时需要合并而不是分解关系模式。合并关系时，应避免引入不必要的数据冗余和“多余”的函数依赖。

##### 10. 规范化理论的指导作用
尽管在实践中不总是严格遵循规范化理论，但这些理论在设计关系数据库模式时仍发挥着重要的指导作用。

通过这些规范化理论的应用，数据库设计者可以创建一个结构合理、数据冗余最小、易于维护的关系数据库模式。规范化有助于提高数据库的性能和可扩展性，但也可能导致查询变得更加复杂，因此，在实际应用中需要根据具体情况权衡规范化的程度。

## 关系模型的冗余和异常问题

### 关系模型的设计问题
**示例**
考虑为管理职工的工资信息而设计一个关系模式

| 职工  | 级别  | 工资  |
| --- | --- | --- |
| 赵明  | 4   | 500 |
| 钱广  | 5   | 600 |
| 孙志  | 6   | 700 |
| 李开  | 5   | 600 |
| 周祥  | 6   | 700 |


**存在的问题**
- **信息的不可表示问题**
	- **插入异常**：如果没有职工具有8级工资，则8级工资的工资数额就难易插入
	- **删除异常**：如果仅有职工赵明具有4级工资，如果将赵明删除，则有关4级工资的工资数额信息也随之删除了
- **信息的冗余问题**
	- **数据冗余：** 职工很多，工资级别有限，每一级别的工资数额反复存储多次
	- **更新异常：** 如果将5级工资的工资数额调为620，则需要找到每个具有5级工资的职工，逐一修改
**解决之道：关系模式分解**

| 级别  | 工资  |
| --- | --- |
| 4   | 500 |
| 5   | 600 |
| 6   | 700 |

| 职工  | 级别  |     |
| --- | --- | --- |
| 赵明  | 4   |     |
| 钱广  | 5   |     |
| 孙志  | 6   |     |
| 李开  | 5   |     |
| 周祥  | 6   |     |
**分解改进后，好处：**
- 数据量减少。
	- 设有n个职工，m个工资级别，n >> m ，则分解前原模式有3n个数据，改进后新模式共有2n+2m个数据，显然后者的数据量要少得多。
- 表达能力强。
	- 分解前原表中无法进入的信息（如9级工资），在改进后的两个模式中则可加入；
	- 当删除职工C时，也不会丢失7级工资信息。
- 修改方便。
	- 改进后，修改某一级别工资时只要修改一处。

**当然，改进后的关系模式也存在另外一个问题，当查询某个职工的工资时，需要将两个关系连接后进行查询，而关系的连接代价是很大的**。

## 数据依赖
### 什么是数据依赖
数据依赖（Data Dependency）是数据库理论中的一个概念，它描述了数据库中数据值之间的特定关系。数据依赖是数据库设计和规范化过程中的一个核心概念，它帮助确保数据的一致性、完整性和减少数据冗余。数据依赖主要包括以下几种类型：
#### 1.  函数依赖（Functional Dependency）：
函数依赖是数据依赖中最常见的一种，它存在于两个属性集之间。如果属性集A的每一个值都能唯一确定属性集B的值，那么称B函数依赖于A，记作A → B。函数依赖是数据库规范化的基础，用于识别数据中的冗余和设计更高效的数据库模式。
函数依赖（Functional Dependency）是关系数据库理论中的一个核心概念，它描述了关系模式中属性之间的一种确定性关系。具体来说，函数依赖指的是关系模式中一个属性集合能够唯一确定另一个属性集合的关系。
**定义**
如果对于关系模式  R(A_1, A_2, ..., A_n)  中的任意两个元组  t_1  和  t_2 ，当  t_1  和  t_2  在属性集合  X  上的值相同时，它们在属性集合  Y  上的值也相同，那么我们就说  X  函数决定  Y ，记作  X \rightarrow Y 。
组成部分
•  X：决定因素（Determinant），它是一个或一组属性的集合，能够决定另一个属性集合的值。
•  Y：被决定因素（Dependent），它是被  X  决定的属性集合。
**特点**
1.  非平凡性：如果  X  函数决定  Y ，且  Y  不是  X  的子集，那么这个函数依赖是非平凡的；否则是平凡的。
2.  传递性：如果  X \rightarrow Y  且  Y \rightarrow Z ，那么  X \rightarrow Z 。
3.  自反性：任何属性集合都函数决定它自己，即  X \rightarrow X 。
4.  对称性：如果  X \rightarrow Y ，那么  Y \rightarrow X  只有在  X  和  Y  相等时才成立。
**应用**
函数依赖在数据库设计中非常重要，特别是在规范化过程中，用于识别和消除数据冗余、插入异常、删除异常和更新异常。通过分析函数依赖，可以将关系模式分解为更小的、更规范化的模式，从而提高数据的一致性和完整性。
**示例**
假设有一个关系模式  Student(SName, SAge, SClass) ，其中  SName  函数决定  SClass （即同一个班级的学生名字不同），可以表示为  SName \rightarrow SClass 。
函数依赖是数据库设计和优化的基础，它帮助数据库管理员和设计师理解和维护数据之间的关系，确保数据的一致性和完整性。

函数依赖是语意范畴的概念。只能根据语义来确定函数依赖性的存在与否
函数依赖反映属性之间的一般规律，必须在关系模式下的任一关系r中都满足约束条件
数据库设计者可以对现实世界作强制的规定。例如规定不允许有同名人出现。函数依赖”姓名-年龄“成立。所插入的元组必须满足规定的函数依赖，若发现有同名人存在，则拒绝装入该元组。

属性间的联系决定函数依赖关系
让我们通过一个具体的例子来说明属性间的联系如何决定函数依赖关系，以及如何使用依赖图来表示这些函数依赖。
实例背景
假设我们有一个大学课程选课系统，需要存储学生信息和课程信息。我们的关系模式如下：
•  Student(S, SN, MA)
•  S: 学生ID
•  SN: 学生姓名
•  MA: 学生所在系
•  Course(C, CN, T)
•  C: 课程ID
•  CN: 课程名称
•  T: 教师姓名
属性间的联系决定函数依赖关系
1.  Student关系模式：
•  在Student关系模式中，学生ID（S）是唯一的，可以唯一确定学生的姓名（SN）和所在系（MA）。因此，我们有以下函数依赖：
•  S → SN
•  S → MA
2.  Course关系模式：
•  在Course关系模式中，课程ID（C）是唯一的，可以唯一确定课程名称（CN）和教师姓名（T）。因此，我们有以下函数依赖：
•  C → CN
•  C → T
依赖图表示函数依赖关系
依赖图是一种图形化工具，用于表示属性间的函数依赖关系。在依赖图中，每个节点代表一个属性，如果存在函数依赖X → Y，则从X指向Y画一条有向边。
依赖图示例
1.  Student依赖图：
S --> SN
S --> MA

在这个图中，S是起点，指向SN和MA，表示学生ID决定了学生的姓名和所在系。
2.  Course依赖图：
C --> CN
C --> T

在这个图中，C是起点，指向CN和T，表示课程ID决定了课程名称和教师姓名。
综合依赖图
如果我们将Student和Course两个关系模式合并到一个更大的关系模式中，比如选课关系模式Enrollment(S, C, G)，其中G是成绩，那么依赖图将更加复杂：
•  Enrollment(S, C, G)
•  S: 学生ID
•  C: 课程ID
•  G: 成绩
在这个关系模式中，我们可能有以下函数依赖：
•  S → MA（学生ID决定所在系）
•  C → T（课程ID决定教师姓名）
•  S, C → G（学生ID和课程ID共同决定成绩）
综合依赖图
  S --> MA
  C --> T
  S --> G
  C --> G
  S,C --> G

在这个图中，S和C都是起点，分别指向MA、T和G，表示学生ID和课程ID决定了所在系、教师姓名和成绩。S和C的组合也指向G，表示学生ID和课程ID共同决定了成绩。
通过这个例子，我们可以看到属性间的联系如何决定函数依赖关系，以及如何使用依赖图来表示这些函数依赖。这有助于我们理解和分析数据库中的数据结构和关系。

##### 平凡函数依赖（Trivial Functional Dependency）
平凡函数依赖是指一个属性集合函数决定它自身，或者一个属性集合函数决定其子集的函数依赖。换句话说，如果函数依赖的右侧（被决定因素）是左侧（决定因素）的子集，那么这个函数依赖就是平凡的。
定义：
•  如果  X \rightarrow Y  且  Y \subseteq X ，则称  X \rightarrow Y  是一个平凡函数依赖。
实例：
假设有一个关系模式  R(A, B, C) ：
•   A \rightarrow A  是一个平凡函数依赖，因为任何属性都能决定它自己。
•   A, B \rightarrow A  也是一个平凡函数依赖，因为决定因素包含了被决定因素  A 。
##### 非平凡函数依赖（Non-Trivial Functional Dependency）
非平凡函数依赖是指一个属性集合函数决定的不是它自身的属性，也不是其子集的属性。这意味着函数依赖的右侧（被决定因素）不是左侧（决定因素）的子集。
定义：
•  如果  X \rightarrow Y  且  Y \not\subseteq X ，则称  X \rightarrow Y  是一个非平凡函数依赖。
实例：
假设有一个关系模式  R(A, B, C) ：
•   A \rightarrow B  是一个非平凡函数依赖，如果  A  的不同值对应  B  的不同值，但  B  不是  A  的子集。
•   A, B \rightarrow C  也是一个非平凡函数依赖，如果  C  的值由  A  和  B  共同决定，且  C  不是  A  或  B  的子集。
相关实例
让我们通过一个具体的例子来说明平凡和非平凡函数依赖：
假设有一个关系模式  Student(SNumber, SName, SMajor) ，其中：
•   SNumber ：学生编号
•   SName ：学生姓名
•   SMajor ：学生专业
平凡函数依赖：
•   SNumber \rightarrow SNumber ：学生编号决定学生编号（自身决定自身）。
•   SNumber, SName \rightarrow SName ：学生编号和姓名共同决定姓名（被决定因素是决定因素的子集）。
非平凡函数依赖：
•   SNumber \rightarrow SName ：学生编号决定学生姓名（学生的编号不同，姓名也不同）。
•   SNumber \rightarrow SMajor ：学生编号决定学生专业（学生的编号不同，专业也不同）。
在这个例子中， SNumber \rightarrow SName  和  SNumber \rightarrow SMajor  都是非平凡函数依赖，因为学生编号决定了不是其子集的其他属性。而  SNumber \rightarrow SNumber  和  SNumber, SName \rightarrow SName  是平凡函数依赖，因为它们分别是属性自身决定自身或属性集合决定其子集。

完全函数依赖和部分函数依赖是关系数据库中描述属性间依赖关系的两个重要概念，它们与候选键和主属性的概念紧密相关。
##### 完全函数依赖（Full Functional Dependency）
如果属性集合  X  函数决定属性  Y ，并且  X  的任何真子集都不能函数决定  Y ，则称  Y  完全函数依赖于  X 。
定义：
•   Y  完全函数依赖于  X ，记作  X \rightarrow Y ，如果对于关系中的任意两个元组  t_1  和  t_2 ，如果  t_1[X] = t_2[X] ，则  t_1[Y] = t_2[Y] ，并且对于  X  的任何真子集  X' ，都存在  t_1  和  t_2  使得  t_1[X'] = t_2[X']  但  t_1[Y] \neq t_2[Y] 。
实例：
假设有一个关系模式  Student(SNumber, SName, Major, Advisor) ，其中：
•   SNumber ：学生编号
•   SName ：学生姓名
•   Major ：专业
•   Advisor ：导师
如果一个学生的专业（Major）完全由学生编号（SNumber）决定，并且没有学生编号的任何真子集能决定专业，则  SNumber  完全函数决定  Major 。
##### 部分函数依赖（Partial Functional Dependency）
如果属性集合  X  函数决定属性  Y ，但  X  的某个真子集也能函数决定  Y ，则称  Y  部分函数依赖于  X 。
定义：
•   Y  部分函数依赖于  X ，记作  X \rightarrow Y ，如果存在  X  的一个真子集  X' ，使得对于关系中的任意两个元组  t_1  和  t_2 ，如果  t_1[X'] = t_2[X'] ，则  t_1[Y] = t_2[Y] 。
实例：
继续使用上述的  Student(SNumber, SName, Major, Advisor)  关系模式，假设：
•   SNumber ：学生编号
•   SName ：学生姓名
•   Major ：专业
•   Advisor ：导师
如果一个学生的导师（Advisor）由学生的专业（Major）决定，但专业本身不是学生编号的子集，且学生编号的任何真子集都不能决定专业，则  Major  部分函数决定  Advisor 。
总结
•  完全函数依赖意味着决定因素  X  的任何真子集都不能决定  Y ， Y  的值完全依赖于  X  的所有属性。
•  部分函数依赖意味着决定因素  X  中的某个真子集就足以决定  Y ， Y  的值不完全依赖于  X  的所有属性。
在数据库设计中，识别完全函数依赖和部分函数依赖对于规范化过程至关重要，因为它们影响数据库的分解和数据的组织方式。

##### 传递函数依赖（Transitive Functional Dependency）
传递函数依赖的定义
传递函数依赖是指在关系模式  R(U)  中，如果存在属性集合  X 、 Y  和  Z ，且  X  函数决定  Y （记作  X \rightarrow Y ）， Y  函数决定  Z （记作  Y \rightarrow Z ），并且  Y  不是  X  的子集， Z  不是  Y  的子集，那么  Z  就传递函数依赖于  X （记作  X \rightarrow Z ）。
相关实例
让我们通过一个具体的例子来说明传递函数依赖：
假设有一个关系模式  Student(Sno, Sdept, Sloc) ，其中：
•   Sno ：学号
•   Sdept ：系别
•   Sloc ：住宿楼号
在这个关系模式中，我们有以下函数依赖：
1.   Sno \rightarrow Sdept ：学号决定系别，即每个学生的学号唯一确定其所属的系别。
2.   Sdept \rightarrow Sloc ：系别决定住宿楼号，即每个系别的学生都被分配到相同的住宿楼号。
根据这些函数依赖，我们可以得出  Sloc  传递函数依赖于  Sno （ Sno \rightarrow Sloc ），因为通过学号我们可以确定系别，再通过系别我们可以确定住宿楼号。
这个例子展示了传递函数依赖的概念，即一个属性的值可以通过另一个属性间接确定，而不是直接依赖。这种依赖关系在数据库设计中很重要，因为它影响数据的组织和规范化过程。

关系汇总函数依赖关系可以用依赖图表示

#### 2.  多值依赖（Multivalued Dependency）：
多值依赖是函数依赖的推广，它涉及到三个或更多属性集。如果对于属性集X的每一个值，属性集Y的值集与属性集Z的值集无关，那么称Y多值依赖于X，记作X →→ Y。多值依赖在数据库设计中用于处理更复杂的数据关系。
多值依赖（Multivalued Dependency，MVD）是数据库理论中的一个重要概念，用于描述关系数据库中属性之间的一种特殊依赖关系。以下是多值依赖的定义和特点：

1. **定义**：
   多值依赖指的是在一个关系模式中，一个属性组X对另一个属性组Y的依赖关系，这种依赖关系与第三个属性组Z无关。形式上，如果R(U)是属性集U上的关系模式，X、Y、Z是U的子集，并且Z=U-X-Y，那么关系模式R(U)中多值依赖X→→Y成立，当且仅当对R(U)的任一关系r，给定的一对(x，z)值有一组Y的值，这组值仅仅决定于x值而与z值无关。

2. **性质**：
   - 对称性：若X→→Y，则X→→Z。
   - 实例r的X或Z每增删一个值，r就须同步增删多条记录。
   - 若X→Y，则X→→Y。故可把函数依赖看成多值依赖的特殊情况。

3. **举例**：
   假设有一个关系<仓库管理员，仓库号，库存产品号>，一个产品只能放到一个仓库中，但是一个仓库可以有若干管理员，那么对应于一个<仓库管理员，库存产品号>有一个仓库号，而实际上，这个仓库号只与库存产品号有关，与管理员无关，就说这是多值依赖。

4. **特点介绍**：
   - 允许X的一个值决定Y的一组值，这种决定关系与Z取值无关。
   - 多值依赖是全模式的依赖关系。
   - 多值依赖的缺点是数据冗余太大。

5. **关系模式分解**：
   为降低数据冗余，作模式分解，使子模式的Z=Ø，仅有平凡多值依赖。对前例，子模式为R1(仓库,雇员),R2(仓库,物资)。

多值依赖是数据库设计中的一个重要概念，它帮助我们理解数据之间的复杂关系，并在数据库的规范化过程中起到关键作用。通过理解和处理多值依赖，可以提高数据库的规范化程度，减少数据冗余，增强数据完整性。
**它可以分为平凡多值依赖和非平凡多值依赖**。

##### 平凡多值依赖（Trivial Multivalued Dependency）

1. **定义**：
   当多值依赖中的决定因素（determinant）X包含被决定因素Y时，这种多值依赖被称为平凡多值依赖。换句话说，如果Y是X的子集（Y ⊆ X），那么X→→Y就是一个平凡多值依赖。

2. **特点**：
   - 平凡多值依赖实际上是函数依赖（Functional Dependency，FD）的一种特殊情况。
   - 在平凡多值依赖中，Y的值完全由X的值决定，因为Y本身就是X的一部分。
   - 平凡多值依赖不会导致数据冗余，因为它们本质上是属性之间的直接关系。

3. **示例**：
   假设有一个关系模式R(A, B, C)，其中A和B是决定因素，C是被决定因素。如果存在一个平凡多值依赖A→→B，那么实际上意味着A→B（因为B是A的子集）。

##### 非平凡多值依赖（Non-trivial Multivalued Dependency）

1. **定义**：
   当多值依赖中的决定因素X不包含被决定因素Y时，这种多值依赖被称为非平凡多值依赖。换句话说，如果Y不是X的子集（Y ⊈ X），那么X→→Y就是一个非平凡多值依赖。

2. **特点**：
   - 非平凡多值依赖描述了一种更复杂的关系，其中X的值决定了Y的一组值，但Y的值并不完全包含在X中。
   - 非平凡多值依赖可能导致数据冗余，因为X的值可以与Y的多个值组合，形成多个不同的元组。
   - 非平凡多值依赖在数据库设计中需要特别注意，因为它们可能违反第三范式（3NF）。

3. **示例**：
   假设有一个关系模式R(D, E, F)，其中D和E是决定因素，F是被决定因素。如果存在一个非平凡多值依赖D→→F，那么D的值可以决定F的一组值，但F的值并不完全包含在D中。例如，如果D代表“部门”，F代表“员工”，那么一个部门可能有多个员工，这就是一个非平凡多值依赖。


平凡多值依赖和非平凡多值依赖的主要区别在于决定因素是否包含被决定因素。平凡多值依赖是函数依赖的特殊情况，通常不会导致数据冗余。而非平凡多值依赖描述了更复杂的关系，可能导致数据冗余，需要在数据库设计中特别注意以避免违反规范化原则。


#### 3.  连接依赖（Join Dependency）：
连接依赖（Join Dependency，JD）是关系数据库理论中的一个概念，它描述了关系数据库中不同关系之间的一种联系。这种依赖关系涉及到两个或多个关系模式的自然连接（Natural Join），并指出了这些关系模式之间如何通过公共属性来连接。

**定义**

连接依赖是一个集合，它包含了一组关系模式，这些关系模式可以通过自然连接操作来合并。如果存在一个连接依赖JD，那么对于JD中的任意两个关系模式R和S，它们可以通过它们共有的属性进行自然连接，并且这个连接操作是有意义的。

**特点**

1. **自然连接**： 连接依赖通常涉及到自然连接，这意味着只有当两个关系模式有相同的属性名时，它们才能进行自然连接。
    
2. **属性覆盖**： 在连接依赖中，每个关系模式的属性集合必须被整个连接依赖集合中的其他关系模式所覆盖。
    
3. **无损连接**： 如果一个连接依赖集合允许无损连接（Lossless Join），那么可以从连接结果中恢复原始的关系模式。无损连接是数据库规范化理论中的一个重要概念，它确保了在分解关系模式时不会丢失信息。
    
4. **依赖保持**： 如果一个连接依赖集合允许依赖保持（Dependency-Preservation），那么在连接操作后，原有的函数依赖和多值依赖仍然得以保持。
    

**示例**

假设有三个关系模式R(A, B, C)，S(B, C, D)和T(C, D, E)。如果存在一个连接依赖JD = {R, S, T}，那么这三个关系模式可以通过它们的公共属性进行自然连接。例如：

- R和S可以通过属性B进行连接。
- S和T可以通过属性C进行连接。
- R和T可以通过属性C间接连接（通过S）。

 **应用**

连接依赖在数据库设计和查询优化中有着重要的应用。它们帮助数据库设计者理解不同关系模式之间的联系，并确保在数据库分解和连接操作中保持数据的完整性和一致性。通过分析连接依赖，可以确定哪些关系模式应该被组合在一起，以及如何优化查询以减少不必要的连接操作。

 **总结**

连接依赖是描述关系数据库中关系模式之间连接操作的一种依赖关系。它涉及到自然连接、属性覆盖、无损连接和依赖保持等概念，对于数据库的设计和查询优化具有重要意义。通过理解和应用连接依赖，可以提高数据库的性能和数据的完整性。
#### 4.  超码依赖（Super Key Dependency）：
超码依赖（Super Key Dependency）是数据库理论中的一个概念，它涉及到关系数据库中属性集合的唯一标识能力。以下是超码依赖的详细解释：

##### 超码（Superkey）
超码是数据库中用来唯一标识实体的属性集合。它能够唯一地识别数据库中的每个实体，因此超码也被称为候选码。超码是数据库设计中的关键概念，它能够帮助我们建立关系模型，规范化数据库，并确保数据的完整性和一致性。

**特点**
1. **唯一性**：超码的一个关键特点是能够唯一标识数据库中的每条记录。这意味着在数据库中不存在两条记录具有相同的超码。
2. **最小性**：超码应该是最小的属性集合，即不能存在一个真子集也能唯一标识数据库中的每条记录。这样可以确保超码的最小性和简洁性。
3. **作用**：超码在数据库中起到唯一标识和定位每个记录的作用。通过超码，我们可以快速找到数据库中的特定记录，并且保证数据的一致性和完整性。

**应用场景**
1. **主键**：超码可以作为主键来唯一标识数据库中的每一条记录。
2. **外键**：超码可以作为外键与其他表进行关联，建立表之间的关系。
3. **数据查询**：通过超码，可以快速定位到需要的记录，提高查询效率。
4. **数据更新**：通过超码，可以准确地更新指定的记录，保证数据的一致性。

**与候选码和主码的关系**
- 超码是候选码的超集。候选码是能够唯一标识实体的最小属性集合，而超码则是包含了候选码的更大的属性集合。
- 在数据库设计中，我们通常选择候选码作为主键，因为它能够最小化数据冗余和复杂性。
- 主码是从候选码中选择的一个用来在同一实体集中区分不同实体的候选码。

总结来说，超码依赖是数据库中用于唯一标识记录的属性集合，它在数据库设计和数据操作中起着重要的作用，可以作为主键、外键，用于数据查询和更新等操作。

#### 5.  候选码依赖（Candidate Key Dependency）：
候选码依赖（Candidate Key Dependency）涉及到数据库中候选码的概念，以下是对候选码依赖的详细解释：

##### 候选码（Candidate Key）
1. **定义**：
   候选码是能够唯一标识关系中某一个元组的最小属性或属性集。这意味着候选码的值能唯一确定关系中的每一条记录，且候选码的任何真子集都不能唯一标识一个元组。

2. **特点**：
   - **唯一性**：候选码中的每个值都唯一地对应数据库中的一条记录，保证记录的唯一性。
   - **最小性**：候选码是由最少数量的属性组成的集合，去掉任何一个属性，候选码就不能唯一标识一条记录。
   - **不可分割性**：候选码中的每个属性都是不可再分割的最小数据单元，即属性是原子的。

3. **应用**：
   候选码在数据库设计中起着至关重要的作用，它们不仅保证数据的完整性和一致性，还为数据库的高效查询提供了基础。

##### 候选码依赖
候选码依赖指的是在关系数据库中，一个属性或属性集对候选码的依赖关系。具体来说，如果一个属性或属性集X能够决定候选码Y，那么存在候选码依赖。这种依赖关系在数据库的规范化过程中非常重要，因为它帮助确定哪些属性是关键的，并且需要被包含在主键中。

##### 与超码依赖的关系
- **超码（Superkey）**：是指一个或多个属性的集合，这些属性的组合可以使我们在一个实体集中唯一地标识一个实体。超码包括候选码，因为候选码是最小的超码，没有无关属性。
- **候选码**：是超码的一个子集，它是能够唯一标识一条记录的最小属性集。

候选码依赖是数据库设计中的一个基本概念，它涉及到候选码与数据库记录标识之间的关系。理解候选码依赖有助于在数据库规范化过程中正确地识别和使用候选码，从而确保数据的完整性和查询效率。

#### 6.  主码依赖（Primary Key Dependency）：
主码是从候选码中选定的一个，用于唯一标识表中的每一行。主码与表中的其他属性集之间存在主码依赖。
主码依赖（Primary Key Dependency）是指在关系数据库中，一个表的主码（Primary Key）与其他属性（列）之间的依赖关系。主码是表中用于唯一标识每个记录的属性或属性组合，而主码依赖则涉及到主码如何影响表中其他属性的值。

##### 主码（Primary Key）
1. **定义**：
   主码是表中的一个或多个属性的组合，这些属性的值可以唯一标识表中的每条记录。主码是候选码的一个实例，通常在数据库设计时被选定为表的主键。

2. **特点**：
   - **唯一性**：主码的值在表中必须是唯一的，不能有重复。
   - **非空性**：主码的值不能为NULL。
   - **稳定性**：主码的值在表的生命周期内是不变的，因为它用于唯一标识记录。

3. **应用**：
   主码用于索引记录，优化查询性能，并且在外键约束中用于关联其他表。

##### 主码依赖
主码依赖是指表中其他属性的值依赖于主码的值。在关系数据库中，这种依赖关系通常体现在以下几个方面：

1. **实体完整性**：
   主码确保了实体的完整性，即表中的每条记录都可以被唯一标识，并且主码的值不能为NULL。

2. **数据一致性**：
   主码依赖有助于维护数据的一致性，因为任何依赖于主码的属性值都必须与主码的值保持一致。

3. **外键约束**：
   在涉及多个表的关系数据库中，一个表的主码可以作为另一个表的外键，从而建立表之间的关系。这种关系就是一种主码依赖，外键的值必须匹配主码表中的相应值。

4. **查询优化**：
   主码依赖可以用于优化数据库查询，因为主码提供了一种快速定位和检索记录的方法。

主码依赖是关系数据库中的一个重要概念，它涉及到主码如何唯一标识记录以及如何影响表中其他属性的值。理解主码依赖有助于设计有效的数据库模式，确保数据的完整性和一致性，并优化数据库操作。在实际应用中，主码依赖还涉及到数据库的规范化、索引创建和查询性能优化等多个方面。


数据依赖在数据库设计中非常重要，因为它们帮助设计者理解数据之间的关系，从而设计出既满足业务需求又避免数据冗余的数据库模式。通过规范化过程，可以消除不必要的数据依赖，提高数据库的性能和可维护性。

#### 关系模式的简化表示
在关系模式R（U，D，DOM，F）中，影响数据库模式设计的主要是U和F，D和DOM对其影响不大，为了方便讨论，我们将关系模式简化为一个三元组：R（U，F）
当且仅当U上的一个关系r满足F时，r称为关系模式R（U，F）的一个关系

让我们通过一个简单的实例来说明数据依赖对关系模式的影响。
实例背景
假设我们有一个大学的学生信息系统，需要存储学生信息、课程信息以及学生的选课信息。
初始关系模式
最初，我们可能会设计一个关系模式 StudentCourse，它包含以下属性：
•  StudentID：学生的唯一标识符
•  StudentName：学生的名字
•  CourseID：课程的唯一标识符
•  CourseName：课程的名字
•  Grade：学生在该课程的成绩
关系模式可以表示为：
`StudentCourse(StudentID, StudentName, CourseID, CourseName, Grade)`

#### 数据依赖分析
1.  函数依赖：
•  StudentID 函数决定 StudentName，即每个学生ID对应一个唯一的学生名字。
•  CourseID 函数决定 CourseName，即每个课程ID对应一个唯一的课程名字。
2.  数据依赖的影响：
•  根据函数依赖，我们发现 StudentName 依赖于 StudentID，CourseName 依赖于 CourseID。这意味着如果我们将 StudentName 和 CourseName 存储在 StudentCourse 表中，会导致数据冗余，因为对于每个学生和课程，这些信息会被多次重复。
规范化后的关系模式
为了解决这个问题，我们可以将关系模式规范化，将 StudentCourse 分解为三个关系模式：
1.  Student：
Student(StudentID, StudentName)

2.  Course：
Course(CourseID, CourseName)

3.  Enrollment：
Enrollment(StudentID, CourseID, Grade)

#### 影响分析
•  减少数据冗余：通过规范化，我们减少了数据冗余，因为 StudentName 和 CourseName 只在它们各自的表中存储一次。
•  提高数据完整性：规范化后的关系模式更容易维护数据完整性，因为任何关于学生或课程的更新只需要在一个地方进行。
•  避免更新异常：在原始的关系模式中，如果添加一个新学生或新课程，我们需要为每个学生的每门课程或每门课程的每个学生添加新行，这可能导致更新异常。规范化后，我们可以轻松地添加新学生或新课程，而不需要修改其他行。
•  查询优化：虽然规范化可能会增加查询时的连接操作，但它也使得查询优化器可以更有效地使用索引和连接，从而可能提高查询性能。

### 如何设计一个合理的关系数据库模式
好的，让我们通过一个简单的“图书馆管理系统”数据库设计实例，来展示上述步骤的操作。
**需求分析**
假设我们需要一个系统来管理图书馆的书籍、读者和借阅信息。
**概念性设计**
	•  实体：书籍（Book）、读者（Reader）、借阅（Borrowing）
	•  关系：
	•  读者与借阅是一对多关系（一个读者可以借多本书）
	•  书籍与借阅也是一对多关系（一本书可以被多个读者借阅）
**确定实体属性**
	•  书籍（Book）：
	•  BookID（书籍ID）
	•  Title（标题）
	•  Author（作者）
	•  ISBN（国际标准书号）
	•  Publisher（出版社）
	•  Year（出版年份）
	•  Quantity（库存数量）
	•  读者（Reader）：
	•  ReaderID（读者ID）
	•  Name（姓名）
	•  Email（电子邮件）
	•  Phone（电话）
	•  Address（地址）
	•  借阅（Borrowing）：
	•  BorrowingID（借阅ID）
	•  ReaderID（读者ID）
	•  BookID（书籍ID）
	•  BorrowDate（借阅日期）
	•  ReturnDate（归还日期）
**定义实体间的关系**
	•  读者与借阅：一对多
	•  书籍与借阅：一对多
**规范化**
•  检查是否存在部分函数依赖和传递依赖，并进行分解以满足3NF。
**确定主键和外键**
	•  主键：
		•  Book(BookID)
		•  Reader(ReaderID)
		•  Borrowing(BorrowingID)
	•  外键：
		•  Borrowing(ReaderID) 引用 Reader(ReaderID)
		•  Borrowing(BookID) 引用 Book(BookID)
**定义视图**
	•  创建视图以简化读者借阅信息的查询。
**索引和性能优化**
	•  对Book.Title、Reader.Name和Borrowing.BorrowDate等字段创建索引。
**安全性和权限**
	•  定义权限，确保只有授权的图书馆工作人员可以修改借阅信息。
**实施约束**
	•  实施实体完整性、参照完整性和域完整性约束。
	•  创建数据字典，记录所有表、字段、关系和约束的详细信息。
**测试和验证**
	•  测试数据库以确保所有功能正常工作，数据完整性得到维护。
**迭代和维护**
	•  根据用户反馈和业务需求对数据库进行调整。
 **备份和恢复策略**
	•  制定定期备份计划，并确保有有效的数据恢复流程。
SQL示例
以下是创建这些表的SQL语句示例：
```sql
CREATE TABLE Book (
    BookID INT PRIMARY KEY,
    Title VARCHAR(255),
    Author VARCHAR(100),
    ISBN VARCHAR(13),
    Publisher VARCHAR(100),
    Year INT,
    Quantity INT
);

CREATE TABLE Reader (
    ReaderID INT PRIMARY KEY,
    Name VARCHAR(100),
    Email VARCHAR(100),
    Phone VARCHAR(20),
    Address VARCHAR(255)
);

CREATE TABLE Borrowing (
    BorrowingID INT PRIMARY KEY,
    ReaderID INT,
    BookID INT,
    BorrowDate DATE,
    ReturnDate DATE,
    FOREIGN KEY (ReaderID) REFERENCES Reader(ReaderID),
    FOREIGN KEY (BookID) REFERENCES Book(BookID)
);
```
这个实例展示了如何从需求分析开始，逐步设计出一个合理的关系数据库模式。实际应用中，每个步骤都可能需要更详细的工作和多次迭代。


### 什么是关系数据库设计理论？
**关系数据库设计的核心：关系模式设计**
关系模式的设计：
按照一定的原则从数量众多而又相互关联的数据中，构造出一组既能较好反映现实世界，而又有良好的操作性能的关系模式。

规范化理论正是用来改造关系模式，通过分解关系模式来消除其中不合适的数据依赖，以插入异常、删除异常、更新异常和数据冗余问题

#### 数据库语义学的重要内容
它借助近代代数工具，提出了一套严密的理论和实用算法，把抽象的数学理论和具体的实际问题结合起来，解决如何设计好一个关系模式问题
是关系数据库设计的指南
理论的基础：数据的依赖

### 码
[[Chapter 2 建立数据模型#码|码的定义以及码相关的知识]]
### 数据依赖的公理系统
#### 定义
**一套推理规则，是模式分解算法的理论基础**

数据依赖的公理系统是数据库理论中用于形式化描述数据之间关系的一种方法。它为数据库设计提供了理论基础，特别是在规范化理论中，用于消除数据冗余和更新异常。

#### 用途

1. **数据库设计**：
    
    - 数据依赖的公理系统是数据库设计中规范化过程的理论基础。通过分析数据依赖，设计者可以确保数据库模式满足第三范式（3NF）或更高，从而减少数据冗余和更新异常。
2. **数据完整性**：
    
    - 通过定义数据依赖，可以确保数据库中数据的完整性和一致性。例如，函数依赖可以确保主键的唯一性。
3. **查询优化**：
    
    - 数据依赖的信息可以用于数据库查询优化。数据库系统可以利用这些信息来选择更有效的查询执行计划。
4. **数据建模**：
    
    - 在数据建模过程中，数据依赖的公理系统帮助识别和定义实体之间的关系，从而构建更加准确和高效的数据模型。
5. **数据库维护**：
    
    - 在数据库的维护和演化过程中，数据依赖的公理系统有助于评估和实施模式的变更，确保变更不会破坏数据的完整性和一致性。



#### Armstrong公理系统

Armstrong公理系统包含三个基本规则，这些规则用于推导函数依赖：

1. **自反律（Reflexivity, A1）**：
   - 若 \( Y \subseteq X \)，则 \( X \rightarrow Y \)。
   - 这意味着如果 \( Y \) 是 \( X \) 的子集，那么 \( X \) 函数决定 \( Y \)。

2. **增广律（Augmentation, A2）**：
   - 若 \( X \rightarrow Y \)，则对于任意属性集 \( Z \)，有 \( XZ \rightarrow YZ \)。
   - 这意味着如果 \( X \) 函数决定 \( Y \)，那么 \( X \) 联合任何其他属性集 \( Z \) 也能决定 \( Y \) 联合 \( Z \)。

3. **传递律（Transitivity, A3）**：
   - 若 \( X \rightarrow Y \) 且 \( Y \rightarrow Z \)，则 \( X \rightarrow Z \)。
   - 这意味着如果 \( X \) 函数决定 \( Y \)，且 \( Y \) 函数决定 \( Z \)，那么 \( X \) 也能函数决定 \( Z \)。

Armstrong公理系统是数据库理论中用于推理函数依赖的一组基本规则。这些规则不仅包括三个基本的公理（自反律、增广律、传递律），还包括由这些公理推导出的一些重要定理和引理。以下是Armstrong公理系统中的一些核心定理和引理：

##### 定理

1. **Armstrong公理的正确性**：
   - 如果函数依赖集 \( F \) 成立，则由 \( F \) 根据Armstrong公理所推导出的所有函数依赖也必然成立。

2. **函数依赖的推导**：
   - 任何可以从函数依赖集 \( F \) 推导出的函数依赖 \( X \rightarrow Y \) 必须满足 \( Y \subseteq X^+ \)，其中 \( A^+ \) 表示属性集 \( A \) 关于 \( F \) 的闭包。

##### 引理

1. **闭包引理**：
   - \( X \rightarrow Y \) 成立的充分必要条件是 \( Y \subseteq X^+ \)。
   - 这个引理说明，如果 \( Y \) 是 \( X \) 的闭包 \( X^+ \) 的子集，那么 \( X \) 函数决定 \( Y \)。

2. **Armstrong公理的完备性**：
   - Armstrong公理系统是完备的，意味着任何有效的函数依赖都可以从已知的函数依赖集中使用这些公理推导出来。

3. **属性闭包的计算**：
   - 通过Armstrong公理系统，可以计算出给定属性集 \( X \) 关于函数依赖集 \( F \) 的闭包 \( X^+ \)。

4. **函数依赖的等价性**：
   - 如果两个函数依赖集 \( F \) 和 \( G \) 可以互相推导出对方的所有函数依赖，那么 \( F \) 和 \( G \) 是等价的。

5. **最小覆盖**：
   - 函数依赖集 \( F \) 的最小覆盖是最小的函数依赖集，它覆盖了 \( F \) 所覆盖的所有函数依赖，且没有冗余的函数依赖。

6. **无损连接和保持函数依赖**：
   - 在关系模式分解时，如果分解后的关系模式满足无损连接性和保持函数依赖，那么这种分解是等价的

##### 推论

由Armstrong公理系统，可以得到以下三个推论：

1. **合成规则（Union Rule）**：
   - 若 \( X \rightarrow Y \) 且 \( X \rightarrow Z \)，则 \( X \rightarrow YZ \)。
   - 这意味着如果 \( X \) 函数决定 \( Y \) 和 \( Z \)，那么 \( X \) 也能函数决定 \( Y \) 和 \( Z \) 的合成。

2. **分解规则（Decomposition Rule）**：
   - 若 \( X \rightarrow YZ \) 且 \( Z \subseteq X \)，则 \( X \rightarrow Y \)。
   - 这意味着如果 \( X \) 函数决定 \( Y \) 和 \( Z \) 的合成，且 \( Z \) 是 \( X \) 的子集，那么 \( X \) 也能函数决定 \( Y \)。

3. **伪传递规则（Pseudotransitivity Rule）**：
   - 若 \( X \rightarrow Y \) 且 \( WY \rightarrow Z \)，则 \( WX \rightarrow Z \)。
   - 这意味着如果 \( X \) 函数决定 \( Y \)，且 \( W \) 和 \( Y \) 联合能函数决定 \( Z \)，那么 \( W \) 和 \( X \) 联合也能函数决定 \( Z \)。

Armstrong公理系统提供了一种机制，用于从已知的函数依赖集中推导出新的函数依赖，这对于数据库设计和规范化至关重要。通过应用这些公理和推论，数据库设计者可以确保数据库模式的完整性和一致性，同时减少数据冗余和避免更新异常。


#### 函数依赖的闭包（Closure of a Functional Dependency）
函数依赖的闭包（Closure of a Functional Dependency）是数据库理论中的一个概念，它在数据库规范化过程中起着重要作用。闭包的概念帮助我们理解在给定的函数依赖下，哪些属性可以被确定。

##### 定义

给定一个关系模式 R(U)，其中 U 是属性集合，F 是该关系模式上函数依赖的集合。对于 U 的任意子集 X，X 的闭包（记作 X+）是指在函数依赖 F 下，由 X 可以确定的所有属性的集合。换句话说，X+ 包含了所有那些可以通过 X 直接或间接推导出的属性。

##### 计算闭包的步骤

1. **初始化**：开始时，将 X+ 设置为 X 本身，即 X+ = X。
    
2. **迭代**：对于 X+ 中的每一个属性 A，检查 F 中是否存在形如 A → B 的函数依赖。如果存在，并且 B 还不在 X+ 中，则将 B 添加到 X+ 中。
    
3. **重复**：重复步骤 2，直到没有新的属性可以添加到 X+ 中为止。
    
4. **结果**：最终的 X+ 就是 X 的闭包。
    

##### 例子

假设有一个关系模式 R(A, B, C, D)，并且有以下函数依赖集 F：

- A → B
- B → C
- C → D

我们要计算 X = {A} 的闭包。

1. 初始时，X+ = {A}。
    
2. 检查 A → B，将 B 添加到 X+ 中，现在 X+ = {A, B}。
    
3. 检查 B → C，将 C 添加到 X+ 中，现在 X+ = {A, B, C}。
    
4. 检查 C → D，将 D 添加到 X+ 中，现在 X+ = {A, B, C, D}。
    
5. 没有新的属性可以添加，闭包计算完成。
    

所以，A+ = {A, B, C, D}。

##### 用途

函数依赖的闭包在数据库设计中用于：

- **确定候选键**：通过计算属性集的闭包，可以确定哪些属性集可以成为候选键。
- **规范化**：在数据库规范化过程中，闭包帮助设计者理解数据依赖的影响，从而设计出更符合规范化要求的数据库模式。
- **查询优化**：在查询优化中，闭包的概念可以用来确定查询结果中哪些属性是确定的，从而优化查询计划。

#### 求解闭包的算法
##### 求解闭包的算法步骤

1. **初始化**：将闭包C初始化为属性集X，即C = X。
    
2. **检查函数依赖**：对于函数依赖集F中的每一个函数依赖X → Y，检查X是否是C的子集。
    
3. **应用增广律**：如果X是C的子集，将Y中的所有属性添加到C中，即C = C ∪ Y。
    
4. **重复**：重复步骤2和3，直到没有新的属性可以添加到C中。
    
5. **完成**：当C不再变化时，算法结束，此时C就是X的闭包。
    

##### 算法示例

假设我们有以下函数依赖集F和属性集X：

F = { A → B, B → C, C → D, E → A }

X = { E }

我们按照算法步骤求解X的闭包：

1. 初始化：C = { E }
    
2. 检查函数依赖：
    
    - E → A，E ∈ C，所以将A添加到C中：C = { E, A }
    - A → B，A ∈ C，所以将B添加到C中：C = { E, A, B }
    - B → C，B ∈ C，所以将C添加到C中：C = { E, A, B, C }
    - C → D，C ∈ C，所以将D添加到C中：C = { E, A, B, C, D }
3. 重复：此时，所有可能的属性都已添加到C中，没有新的属性可以添加。
    
4. 完成：算法结束，X的闭包是C = { E, A, B, C, D }。
    

##### 注意事项

- 在实际应用中，可能需要对函数依赖集进行化简，以减少计算量。
- 算法的效率取决于函数依赖集的大小和复杂性。
- 在某些情况下，可能需要使用更高效的算法，如基于图的算法，来求解闭包。

#### 求解函数依赖闭包的算法的伪代码
以下是求解函数依赖闭包的算法的伪代码表示，这个算法基于Armstrong公理，并采用迭代的方法来计算闭包。


```plaintext
算法：计算属性集X的闭包
输入：属性集X，函数依赖集F
输出：属性集X的闭包X+

1. 初始化闭包 C = X
2. 标记一个布尔变量 changed 为 true，用于检测闭包是否改变
3. 当 changed 为 true 时，执行以下步骤：
   a. 将 changed 设置为 false
   b. 对于 F 中的每个函数依赖 Y → Z：
      i. 如果 Y ⊆ C（Y是C的子集）：
         1. 将 Z 中不在 C 的属性添加到 C 中
         2. 将 changed 设置为 true
4. 返回 C
```

这个伪代码描述了一个简单的算法，用于计算给定属性集X在函数依赖集F下的闭包。以下是算法的详细步骤：

1. **初始化**：开始时，将闭包C初始化为属性集X。
    
2. **迭代**：使用一个循环，直到没有新的属性可以添加到C中。这个循环由变量`changed`控制，它是一个布尔标志，用于指示在当前迭代中是否向闭包中添加了新属性。
    
3. **检查函数依赖**：在每次迭代中，检查函数依赖集F中的每个函数依赖Y → Z。
    
4. **应用增广律**：如果Y是C的子集，这意味着我们可以通过Y推导出Z。因此，将Z中所有不在C中的属性添加到C中，并将`changed`设置为true。
    
5. **重复**：重复步骤3和4，直到一次迭代中没有新的属性被添加到C中，即`changed`为false。
    
6. **返回结果**：当循环结束时，C包含了所有可以由X推导出的属性，即X的闭包。

##### 求解闭包的示例
###### 示例 1

**函数依赖集 F**: { A → B, B → C, C → D }

**属性集 X**: { A }

**求解闭包 X+**:

1. 初始化：C = { A }
2. 检查 A → B，因为 A ∈ C，所以将 B 添加到 C 中：C = { A, B }
3. 检查 B → C，因为 B ∈ C，所以将 C 添加到 C 中：C = { A, B, C }
4. 检查 C → D，因为 C ∈ C，所以将 D 添加到 C 中：C = { A, B, C, D }
5. 没有新的属性可以添加，闭包计算完成。

**结果**: A+ = { A, B, C, D }

###### 示例 2

**函数依赖集 F**: { X → Y, Y → Z, X → W, W → Z }

**属性集 X**: { X }

**求解闭包 X+**:

1. 初始化：C = { X }
2. 检查 X → Y，因为 X ∈ C，所以将 Y 添加到 C 中：C = { X, Y }
3. 检查 X → W，因为 X ∈ C，所以将 W 添加到 C 中：C = { X, Y, W }
4. 检查 Y → Z，因为 Y ∈ C，所以将 Z 添加到 C 中：C = { X, Y, W, Z }
5. 检查 W → Z，但 Z 已经在 C 中，所以不添加。
6. 没有新的属性可以添加，闭包计算完成。

**结果**: X+ = { X, Y, W, Z }

###### 示例 3

**函数依赖集 F**: { (A, B) → C, C → D, B → E }

**属性集 X**: { A, B }

**求解闭包 X+**:

1. 初始化：C = { A, B }
2. 检查 (A, B) → C，因为 { A, B } ∈ C，所以将 C 添加到 C 中：C = { A, B, C }
3. 检查 C → D，因为 C ∈ C，所以将 D 添加到 C 中：C = { A, B, C, D }
4. 检查 B → E，因为 B ∈ C，所以将 E 添加到 C 中：C = { A, B, C, D, E }
5. 没有新的属性可以添加，闭包计算完成。

**结果**: { A, B }+ = { A, B, C, D, E }

###### 示例 4

**函数依赖集 F**: { A → B, B → C, A → D, C → E }

**属性集 X**: { A }

**求解闭包 X+**:

1. 初始化：C = { A }
2. 检查 A → B，因为 A ∈ C，所以将 B 添加到 C 中：C = { A, B }
3. 检查 A → D，因为 A ∈ C，所以将 D 添加到 C 中：C = { A, B, D }
4. 检查 B → C，因为 B ∈ C，所以将 C 添加到 C 中：C = { A, B, C, D }
5. 检查 C → E，因为 C ∈ C，所以将 E 添加到 C 中：C = { A, B, C, D, E }
6. 没有新的属性可以添加，闭包计算完成。

**结果**: A+ = { A, B, C, D, E }


#### 闭包求解与码

1. **闭包算法的用途**：
    
    - 闭包算法用于判断一个新的函数依赖是否能够从给定的函数依赖集F中推导出来。
    - 通过闭包算法，我们可以从关系R(U,F)中给定的函数依赖集合F推导出所有的函数依赖。
2. **超码的定义**：
    
    - 在关系R(U,F)中，如果某个属性集K是U的子集（K ⊆ U），并且K关于函数依赖集F的闭包K+包含了R的所有属性集合U（K+ = U），那么K被称为关系R的超码。
3. **候选码的定义**：
    
    - 如果属性集K是超码，并且K中不存在任何真子集K'（K' ⊂ K），使得K'的闭包(K')+也等于U，那么K就是关系R(U,F)的候选码。
    - 候选码是最小的超码，它不能由其任何真子集推导出来。

- **闭包求解的过程**：
    
    - 初始化闭包C为属性集K。
    - 迭代地应用函数依赖集F中的规则，将可以由C推导出的属性添加到C中。
    - 当迭代过程中没有新的属性被添加到C中时，闭包求解完成。
- **候选码的确定**：
    
    - 确定候选码需要检查所有可能的属性集及其闭包，这可能涉及到复杂的计算，特别是当属性集U较大时。
    - 候选码的确定是数据库设计中的关键步骤，因为它直接影响到数据库的规范化程度和性能。
- **码的应用**：
    
    - 码（特别是候选码）在数据库设计中用于定义表的主键，确保数据的唯一性和完整性。
    - 通过选择合适的候选码作为主键，可以优化数据库的存储和查询效率。
- **闭包求解的算法**：
    
    - 伪代码表示如下：
        
        ```
        function calculateClosure(K, F):
            C = K
            changed = true
            while changed:
                changed = false
                for each X → Y in F:
                    if X ⊆ C and not Y ⊆ C:
                        C = C ∪ Y
                        changed = true
            return C
        ```
        
    - 这个算法通过不断迭代，直到没有新的属性可以添加到闭包C中，从而求解出属性集K的闭包。

#### 候选码的求解理论和算法

##### 候选码的求解理论和算法

1. **属性分类**：
    
    - **L类**：仅出现在函数依赖集F的左部的属性。
    - **R类**：仅出现在函数依赖集F的右部的属性。
    - **N类**：在函数依赖集F的左右两部均未出现的属性。
    - **LR类**：在函数依赖集F的左右两部均出现的属性。
2. **定理**：
    
    对于给定的关系模式R及其函数依赖集F，若X是R的R类属性，则X不是R的任何候选码的成员。
	对于给定的关系模式R及其函数依赖集F，若X是R的N类属性，则X必为R的任一候选码的成员。

3. **推论**：
    
    - 对于给定的关系模式R及其函数依赖集F，如果属性X是R的L类属性，并且X的闭包X+包含了R的全部属性，那么X必然是R的唯一候选码。
    

- **候选码的求解**：
    
    - 候选码的求解涉及到对属性的分类和闭包的计算。通过分析函数依赖集F，我们可以确定哪些属性是L类、R类、N类或LR类。
    - 利用这些分类，我们可以应用上述定理和推论来确定候选码。
- **示例**： 假设有一个关系模式R(A, B, C)和函数依赖集F = { A → B, C → A }。
    
    - **属性分类**：
        
        - L类：{ A, C }（因为A和C只出现在函数依赖的左部）
        - R类：{ B }（因为B只出现在函数依赖的右部）
        - N类：{}（没有属性在函数依赖的左右两部都不出现）
        - LR类：{}（没有属性在函数依赖的左右两部都出现）
    - **应用定理**：
        
        - A和C都是L类属性，我们需要检查它们的闭包是否包含所有属性。
    - **计算闭包**：
        
        - A+ = { A, B }（因为A → B）
        - C+ = { C, A, B }（因为C → A，然后A → B）
    - **应用推论**：
        
        - 由于C+包含了R的全部属性，且C是L类属性，所以C是R的唯一候选码。

##### 注意事项
- 在实际应用中，可能需要对函数依赖集进行化简，以减少计算量。
- 候选码的确定是数据库设计中的关键步骤，因为它直接影响到数据库的规范化程度和性能。
- 通过选择合适的候选码作为主键，可以优化数据库的存储和查询效率。

##### 相关示例

###### 示例 1

**关系模式 R**: (A, B, C)

**函数依赖集 F**: { A → B, B → C }

**求解候选码**:

1. **属性分类**:
    
    - L类: { A }（A 出现在函数依赖的左部）
    - R类: { C }（C 只出现在函数依赖的右部）
    - N类: {}（没有属性在函数依赖的左右两部都不出现）
    - LR类: { B }（B 在函数依赖的左右两部都出现）
2. **应用定理**:
    
    - A 是 L类属性，我们需要检查 A+ 是否包含所有属性。
3. **计算闭包**:
    
    - A+ = { A, B, C }（因为 A → B, 然后 B → C）
4. **应用推论**:
    
    - A+ 包含了 R 的全部属性，且 A 是 L类属性，所以 A 是 R 的候选码。

###### 示例 2

**关系模式 R**: (X, Y, Z)

**函数依赖集 F**: { X → Y, Y → Z }

**求解候选码**:

1. **属性分类**:
    
    - L类: { X }（X 出现在函数依赖的左部）
    - R类: { Z }（Z 只出现在函数依赖的右部）
    - N类: {}（没有属性在函数依赖的左右两部都不出现）
    - LR类: { Y }（Y 在函数依赖的左右两部都出现）
2. **应用定理**:
    
    - X 是 L类属性，我们需要检查 X+ 是否包含所有属性。
3. **计算闭包**:
    
    - X+ = { X, Y, Z }（因为 X → Y, 然后 Y → Z）
4. **应用推论**:
    
    - X+ 包含了 R 的全部属性，且 X 是 L类属性，所以 X 是 R 的候选码。

###### 示例 3

**关系模式 R**: (A, B, C, D)

**函数依赖集 F**: { A → B, B → C, C → D }

**求解候选码**:

1. **属性分类**:
    
    - L类: { A }（A 出现在函数依赖的左部）
    - R类: { D }（D 只出现在函数依赖的右部）
    - N类: {}（没有属性在函数依赖的左右两部都不出现）
    - LR类: { B, C }（B 和 C 在函数依赖的左右两部都出现）
2. **应用定理**:
    
    - A 是 L类属性，我们需要检查 A+ 是否包含所有属性。
3. **计算闭包**:
    
    - A+ = { A, B, C, D }（因为 A → B, B → C, 然后 C → D）
4. **应用推论**:
    
    - A+ 包含了 R 的全部属性，且 A 是 L类属性，所以 A 是 R 的候选码。

###### 示例 4

**关系模式 R**: (E, F, G, H)

**函数依赖集 F**: { E → F, F → G, G → H }

**求解候选码**:

1. **属性分类**:
    
    - L类: { E }（E 出现在函数依赖的左部）
    - R类: { H }（H 只出现在函数依赖的右部）
    - N类: {}（没有属性在函数依赖的左右两部都不出现）
    - LR类: { F, G }（F 和 G 在函数依赖的左右两部都出现）
2. **应用定理**:
    
    - E 是 L类属性，我们需要检查 E+ 是否包含所有属性。
3. **计算闭包**:
    
    - E+ = { E, F, G, H }（因为 E → F, F → G, 然后 G → H）
4. **应用推论**:
    
    - E+ 包含了 R 的全部属性，且 E 是 L类属性，所以 E 是 R 的候选码。、

###### 示例 5
**** 关系模式

- S(S#,SN,SD,DMN,C#,G)S(S#,SN,SD,DMN,C#,G)
    - 其中，S#S# 表示学生编号，SNSN 表示学生姓名，SDSD 表示学生系别，DMNDMN 表示系主任姓名，C#C# 表示课程编号，GG 表示成绩。

 **函数依赖**

1. (S#,C#)→fG(S#,C#)f​G
    
    - 表示学生编号和课程编号共同决定成绩。
2. S#→SNS#→SN
    
    - 表示学生编号决定学生姓名。
3. (S#,C#)→pSN(S#,C#)p​SN
    
    - 表示学生编号和课程编号共同决定学生姓名，这可能是一个错误，因为通常学生姓名由学生编号决定，而不是与课程编号共同决定。
4. S#→SDS#→SD
    
    - 表示学生编号决定学生所属的系别。
5. (S#,C#)→pSD(S#,C#)p​SD
    
    - 表示学生编号和课程编号共同决定学生所属的系别，这也可能是一个错误，因为通常学生所属的系别由学生编号决定。
6. SD→DMNSD→DMN
    
    - 表示系别决定系主任姓名。

**候选码**

- (S#,C#)(S#,C#)
    - 表示学生编号和课程编号的组合是一个候选码，即它们可以唯一确定关系中的所有其他属性。

#### 函数依赖集等价
1. **函数依赖（Functional Dependency）**：在关系数据库中，如果对于每一个元组（行）的集合，属性集X的值能够唯一确定属性集Y的值，那么我们说X函数决定Y，记作X → Y。
    
2. **闭包（Closure）**：对于属性集X，其闭包X+表示在给定的函数依赖集下，X能够函数决定的所有属性的集合。
    
3. **等价（Equivalence）**：如果两个函数依赖集F和G的闭包相等，即G+ = F+，那么我们说F覆盖G（F是G的覆盖），或者G覆盖F（G是F的覆盖），或者F与G等价。
    
- **覆盖（Covering）**：如果一个函数依赖集能够推导出另一个函数依赖集的所有函数依赖，那么前者被称为后者的覆盖。
    
- **最小覆盖（Minimal Cover）**：一个函数依赖集的最小覆盖是指在该集合中，没有任何函数依赖是多余的，即移除任何一个函数依赖都会改变闭包的结果。
    
- **属性集（Attribute Set）**：在关系数据库中，属性集是指表中的一列或多列的集合。
    
- **候选键（Candidate Key）**：一个属性集，如果它的闭包包含了所有属性，并且它是最小的（即没有任何真子集也具有这个性质），那么这个属性集就是一个候选键。
    
- **主键（Primary Key）**：在候选键中选择一个作为主键，用于唯一标识表中的每一行。
    
- **规范化（Normalization）**：通过消除数据冗余和更新异常来设计数据库的过程。函数依赖集等价的概念在数据库规范化过程中非常重要，特别是在第一范式（1NF）、第二范式（2NF）和第三范式（3NF）的设计中。
#### 最小函数依赖集

最小函数依赖集（Minimal Functional Dependency Set）是数据库设计中的一个重要概念，特别是在数据库规范化过程中。以下是最小函数依赖集的定义和相关特性：

##### 定义
一个函数依赖集被称为最小，如果满足以下条件：
1. **无冗余依赖**：集合中的任何一个函数依赖都不能由集合中的其他依赖推导出来。
2. **左部单一属性**：每个函数依赖的左部（决定因素）只包含一个属性。这有助于避免复杂的决定因素，使得依赖关系更清晰。

##### 特性
1. **不可分解性**：最小函数依赖集中的每个依赖都不能被进一步分解。如果一个依赖可以被分解为两个或更多的依赖，那么这个集合就不是最小的。

2. **无冗余属性**：在最小函数依赖集中，没有属性是多余的。移除任何一个属性都会导致至少一个依赖无法被正确表示。

3. **无冗余依赖**：集合中的每个依赖都是必要的，不能通过其他依赖的组合来替代。

##### 构建最小函数依赖集的步骤
1. **分解复合依赖**：将所有复合依赖（左部有多个属性的依赖）分解为单个属性的依赖。

2. **消除冗余依赖**：检查每个依赖是否可以由其他依赖推导出来，如果可以，则移除它。

3. **消除冗余属性**：对于每个依赖，检查左部的每个属性是否都是必要的。如果移除某个属性后，依赖仍然成立，则该属性是冗余的。

4. **检查左部单一属性**：确保每个依赖的左部只有一个属性。

##### 应用
最小函数依赖集在数据库设计中用于：
- **规范化**：帮助设计满足特定范式（如BCNF）的数据库模式。
- **减少数据冗余**：通过消除冗余依赖，减少数据存储中的冗余。
- **提高数据完整性**：确保数据的一致性和完整性，避免更新异常。

最小函数依赖集是数据库设计中实现数据优化和规范化的关键工具，有助于创建更高效、更可靠的数据库系统。
##### 示例：学生选课系统

假设我们有一个学生选课系统的数据库，包含以下属性：

- 学生ID（StudentID）
- 课程ID（CourseID）
- 教师ID（TeacherID）
- 成绩（Grade）

我们有以下函数依赖关系：

1. StudentID → CourseID
2. CourseID → TeacherID
3. StudentID, CourseID → Grade

###### 步骤1：分解复合依赖

在这个例子中，所有的函数依赖左部都是单一属性，所以我们不需要进行分解。

###### 步骤2：消除冗余依赖

我们需要检查是否有任何依赖可以由其他依赖推导出来。在这个例子中，没有这样的依赖。

###### 步骤3：消除冗余属性

我们需要检查每个依赖的左部属性是否都是必要的。在这个例子中，每个依赖的左部属性都是必要的，因为：

- 没有单个学生ID可以确定课程ID（可能一个学生选修多门课程）。
- 没有单个课程ID可以确定教师ID（可能一门课程由多个教师教授）。
- 学生ID和课程ID的组合是确定成绩的必要条件。

###### 步骤4：检查左部单一属性

在这个例子中，每个依赖的左部都已经是单一属性。

###### 最小函数依赖集

经过上述步骤，我们得到的最小函数依赖集为：

1. StudentID → CourseID
2. CourseID → TeacherID
3. StudentID, CourseID → Grade

这个最小函数依赖集满足了以下条件：

- 没有冗余依赖。
- 没有冗余属性。
- 左部属性都是单一的。

###### 应用

这个最小函数依赖集可以用于数据库设计，确保数据的规范化，减少冗余，提高数据完整性。例如，我们可以设计一个关系模式，其中包含三个关系：

- 学生（StudentID, CourseID）
- 课程（CourseID, TeacherID）
- 成绩（StudentID, CourseID, Grade）

这样的设计可以避免数据冗余，确保数据的一致性。


## 范式
数据库的范式（Normalization Form）是关系数据库设计中用于减少数据冗余和依赖性的一种理论框架。范式化是数据库设计过程中的一个重要步骤，它有助于提高数据的完整性和减少数据异常。以下是数据库设计中常见的几种范式的定义：

1. **第一范式（1NF）**：
   - 每个表的每列都必须是不可分割的基本数据项。
   - 每个字段都只能包含一个值，不能是集合、数组或多值属性。
   - 所有字段都是原子性的。

2. **第二范式（2NF）**：
   - 满足1NF的要求。
   - 表中没有非主属性对码的部分函数依赖。这意味着如果存在一个非主键属性，它必须完全依赖于主键，而不是主键的一部分。

3. **第三范式（3NF）**：
   - 满足2NF的要求。
   - 表中没有非主属性对码的传递函数依赖。这意味着如果一个非主键属性依赖于另一个非主键属性，那么这个依赖必须直接通过主键。

4. **BC范式（BCNF）**：
   - 满足3NF的要求。
   - 对于表中的每一个非平凡函数依赖X → Y，X都必须是超码。超码是包含候选键的任何属性集。

5. **第四范式（4NF）**：
   - 满足BCNF的要求。
   - 表中没有多值依赖。如果存在多值依赖，那么这些依赖必须是可分解的，即它们可以被分解成多个表，每个表只包含一个值。

6. **第五范式（5NF）**：
   - 也称为投影-连接-正规化（Projection-Join Normal Form，PJNF）。
   - 满足4NF的要求。
   - 确保表中的所有连接依赖都是由候选键决定的。

7. **域/键范式（DKNF）**：
   - 满足5NF的要求。
   - 确保表中的所有函数依赖都可以由域约束和键约束推导出来。


![[NORMRAL FORM.png]]
范式化的过程通常从低级范式开始，逐步向高级范式发展，以消除不同类型的数据冗余和异常。然而，过度范式化可能会导致查询效率降低，因此在实际应用中需要根据具体情况权衡。

### 第一范式（1NF）
第一范式（1NF）是数据库表设计中最基本的规范化形式。它要求数据库表的每列都是不可分割的基本数据项，即每个字段都只包含一个值，没有重复的组或数组。以下是第一范式的定义和示例：

#### 第一范式的定义
一个数据库表满足第一范式，如果：
1. 表中的每一列都是原子性的，即每个字段都不可再分。
2. 每个字段都只包含一个值，而不是一组值。
3. 表中不包含重复的列或组。

#### 示例
假设我们有一个学生信息表，包含以下信息：
- 学生ID
- 姓名
- 年龄
- 课程列表（学生所选的所有课程）

在未规范化的情况下，表可能如下所示：

| 学生ID | 姓名   | 年龄 | 课程1 | 课程2 | 课程3 |
|--------|--------|------|-------|-------|-------|
| 1      | 张三   | 20   | 数学  | 物理  |       |
| 2      | 李四   | 22   | 化学  | 英语  | 历史  |
| 3      | 王五   | 21   | 物理  |       |       |

这个表不符合1NF，因为“课程1”、“课程2”和“课程3”列可以包含多个值（学生可能选修多门课程），这违反了原子性的要求。

#### 规范化为1NF
为了满足1NF，我们需要将表重新设计，使得每个字段都只包含一个值。这通常涉及到将原始表分解为多个表。以下是规范化后的表：

**学生表**

| 学生ID | 姓名   | 年龄 |
|--------|--------|------|
| 1      | 张三   | 20   |
| 2      | 李四   | 22   |
| 3      | 王五   | 21   |

**选课表**

| 学生ID | 课程   |
|--------|--------|
| 1      | 数学   |
| 1      | 物理   |
| 2      | 化学   |
| 2      | 英语   |
| 2      | 历史   |
| 3      | 物理   |

现在，每个表都满足1NF的要求：
- 每个字段都只包含一个值。
- 没有重复的列。
- 没有字段可以进一步分解。

这种设计减少了数据冗余，并使得数据操作更加清晰和简单。例如，如果需要添加或删除课程，只需在选课表中进行，而不需要修改学生表。

#### 非规范化关系
关系数据库模型确实可以存储非规范化的关系，即使这些关系不满足第一范式（1NF）的要求。

1. **关系数据库的灵活性**：关系数据库管理系统（RDBMS）设计上是灵活的，可以存储任何形式的数据，包括那些不符合1NF的数据。这意味着RDBMS可以存储非规范化的关系。

2. **非规范化关系的存储**：在实际应用中，可能会因为性能、存储效率或其他业务需求而选择存储非规范化的数据。例如，为了提高查询性能，可能会在某些情况下故意保留冗余数据。

3. **规范化的目的**：规范化的目的是为了减少数据冗余、避免更新异常、插入异常和删除异常，提高数据的一致性和完整性。规范化是数据库设计的一个目标，而不是数据库系统强制执行的规则。

4. **规范化过程**：在数据库设计过程中，设计者会根据规范化理论来设计数据库模式，以满足1NF、2NF、3NF等范式的要求。这是一个设计选择，而不是数据库系统的限制。

5. **性能与规范化的权衡**：在某些情况下，为了提高查询性能，可能会牺牲一些规范化的原则。例如，通过重复存储某些数据来减少查询时的JOIN操作。

6. **数据模型与数据库系统的区别**：关系数据模型是一个理论框架，它定义了关系数据库应该如何组织数据。而关系数据库系统是实现这个模型的软件，它提供了存储和操作数据的工具。

综上所述，关系数据库可以存储非规范化的关系，但规范化是数据库设计中推荐遵循的原则，以确保数据的质量和系统的可维护性。在设计数据库时，应该根据实际需求和性能考虑来决定是否采用规范化设计。


### 第二范式（2NF）
第二范式（2NF）是数据库设计中用于减少数据冗余和依赖性的一种规范化形式。它建立在第一范式（1NF）的基础上，要求数据库表中的所有非主键属性完全依赖于主键，而不是主键的一部分。以下是第二范式的定义和示例：

#### 第二范式的定义
一个数据库表满足第二范式，如果：
1. 它满足第一范式（1NF）的要求，即表中的每一列都是原子性的，不可再分。
2. 表中的非主键属性完全依赖于整个主键，而不是主键的一部分。这意味着不存在非主键属性只依赖于主键的某个部分的情况，即不存在部分依赖。
3. 1. **关系模型的2NF**：若关系模型H包含的每一关系模式都是2NF的，则称该关系模型是2NF的。
4. **2NF与1NF的关系**：2NF是1NF的超集，即所有满足2NF的关系模式也必然满足1NF的要求。
#### 不良特性

在您提供的关系模式S(S#, SN, SD, DMN, C#, G)中，存在以下不良特性：

1. **插入异常**：如果一个学生尚未选课，那么他的个人信息（如姓名SN、所在系SD）和系信息（DMN）就无法被插入到数据库中，因为主键（学号S#和课程号C#）尚未确定。
    
2. **删除异常**：如果一个学生的选课记录被删除，那么他的个人信息和所在系的信息也会随之丢失，即使这些信息对于其他记录（如其他课程）仍然是有效的。
    
3. **更新异常**：如果一个学生转系，那么他所有选课记录中的系信息都需要更新。如果一个学生选修了k门课，那么就需要修改k次，这不仅耗时，而且容易出错。
    
4. **数据冗余**：如果一个学生选修了k门课，那么他的所在系信息就会在每门课的记录中重复出现，这不仅浪费存储空间，而且增加了数据维护的复杂性。
#### 示例
假设我们有一个选课关系表SelectCourse，包含以下字段：
- 学号（StudentID）
- 姓名（Name）
- 年龄（Age）
- 课程名称（CourseName）
- 成绩（Grade）
- 学分（Credits）

关键字为组合关键字（学号, 课程名称），存在如下决定关系：
- (学号, 课程名称) → (姓名, 年龄, 成绩, 学分)

这个数据库表不满足第二范式，因为存在如下决定关系：
- (课程名称) → (学分)
- (学号) → (姓名, 年龄)

即存在组合关键字中的字段决定非关键字的情况。由于不符合2NF，这个选课关系表会存在数据冗余、更新异常、插入异常等问题。

为了满足第二范式，我们需要将表分解为两个表：
**学生信息表**
- 学号（StudentID）
- 姓名（Name）
- 年龄（Age）

**选课信息表**
- 学号（StudentID）
- 课程名称（CourseName）
- 成绩（Grade）
- 学分（Credits）

在规范化后的表中，每个非主键属性都完全依赖于主键，没有部分依赖，从而满足了第二范式的要求。这样设计可以减少数据冗余，提高数据的一致性和完整性。

### 第三范式（3NF)
第三范式（3NF）是数据库规范化的进一步发展，旨在消除数据冗余和更新异常。

#### 定义
一个数据库表满足第三范式，如果：
1. 它满足第二范式（2NF）的要求。
2. 非主键属性不依赖于其他非主键属性，即不存在传递依赖。
3. **消除传递依赖**：在关系模式R<U, F>中，如果不存在这样的码X，属性组Y及非主属性Z（Z是Y的子集），使得X→Y, Y→Z, Y→X成立，则称R是第三范式，简记为R∈3NF。
#### 特性

1. **消除传递依赖**：3NF要求消除非主属性对码的传递依赖，即非主属性不能依赖于其他非主属性。
2. **关系模型的3NF**：若关系模型R包含的每一关系模式都是3NF的，则称该关系模型是3NF的。
3. **3NF与2NF和1NF的关系**：一个3NF的关系（模式）必定是2NF的，同时也是1NF的。这意味着3NF是2NF的超集，2NF又是1NF的超集。

#### 不良特性
关系模式S_SD(S#, SN, SD, DMN)中，存在以下不良特性：

1. **插入异常**：如果一个系中没有学生，那么该系的信息（如系主任DMN）就无法插入数据库。

2. **删除异常**：如果一个系的所有学生都毕业了，那么在删除学生信息的同时，该系的信息也会丢失。

3. **更新异常**：如果一个学生转系，需要修改学生记录中的系代码（SD）和系主任（DMN）。如果系主任更换，那么该系所有学生的记录都需要更新。

4. **数据冗余**：每个学生记录中都存储了所在系的系主任信息，这导致了数据冗余。

#### 规范化建议
为了解决上述问题，可以采取以下规范化措施：

1. **分解表**：将原始表分解为多个表，以消除传递依赖和数据冗余。例如，可以创建一个学生表，一个系表，和一个系主任表。

2. **学生表**：包含学号（S#）和姓名（SN）。

3. **系表**：包含系代码（SD）和系名称。

4. **系主任表**：包含系代码（SD）和系主任姓名（DMN）。

5. **学生-系关联表**：包含学号（S#）和系代码（SD），用于表示学生和系之间的关系。

通过这样的设计，可以确保数据库表满足3NF的要求，从而减少数据冗余，避免更新、插入和删除异常。

#### 示例
假设有一个大学数据库，包含以下信息：

- 学生（StudentID, StudentName, DepartmentID）
- 系（DepartmentID, DepartmentName, HeadID）
- 系主任（HeadID, HeadName）

在这个设计中：
- 学生表存储学生的基本信息和他们所属的系。
- 系表存储系的基本信息和系主任的ID。
- 系主任表存储系主任的姓名和ID。

这样的设计满足了3NF的要求，因为：
- 所有非主键属性都完全依赖于主键。
- 没有非主键属性依赖于其他非主键属性（没有传递依赖）。

这种规范化的设计有助于维护数据的一致性和减少数据冗余。

### BCNF（Boyce-Codd Normal Form）
BCNF（Boyce-Codd Normal Form）是数据库设计中的一种规范化范式，它是在第三范式（3NF）的基础上进一步规范化的形式。BCNF要求数据库中的每个关系都满足以下条件：

1. 所有的函数依赖都是完全函数依赖：对于关系中的每个属性组，不存在一个属性可以由其他属性的子集唯一确定。也就是说，每个属性都必须依赖于整个主键。
    
2. 不存在任何部分函数依赖：关系中的每个非主属性都不能部分地依赖于主键。即非主属性必须完全依赖于主键，不能仅依赖于主键的一部分。
    
3. 不存在任何传递函数依赖：关系中不存在非主属性之间的传递函数依赖。也就是说，如果 A 依赖于 B，B 依赖于 C，那么 A 不能直接依赖于 C。
    

BCNF与3NF的关系是，BCNF是3NF的加强版。3NF要求每一个非主属性既不部分依赖于码也不传递依赖于码，而BCNF则进一步要求消除了主属性对候选码的部分和传递函数依赖。相对于BCNF，3NF允许存在主属性对候选码的传递依赖和部分依赖。

相关定理包括：

- 一个3NF的关系（模式）必定是2NF的，因为3NF在2NF的基础上进一步消除了非主属性对主键的传递依赖。但是，若R∈3NF，则R未必属于BCNF，因为BCNF有更严格的要求，即所有决定因素都必须包含主键。
- BCNF中的所有依赖的左部都必须包含候选键。这意味着在BCNF中，不存在非候选键决定候选键的情况，这有助于减少数据冗余和维护数据的一致性。


让我们通过一个例子来说明BCNF（Boyce-Codd Normal Form）的概念以及它与3NF的区别。

#### 示例：大学课程安排系统

假设我们有一个大学课程安排系统的数据库，包含以下信息：

- 学生（StudentID, StudentName）
- 课程（CourseID, CourseName, InstructorID）
- 教师（InstructorID, InstructorName）
- 课程安排（CourseID, InstructorID, Time, Location）

在这个系统中，我们有以下函数依赖：

1. StudentID → StudentName
2. CourseID → CourseName
3. InstructorID → InstructorName
4. (CourseID, InstructorID) → Time, Location

##### 3NF分析
在3NF中，我们要求消除非主属性对主键的传递依赖。在这个例子中，如果我们的关系模式是：

**CourseSchedule(CourseID, InstructorID, Time, Location, StudentID, StudentName)**

这个关系模式可能满足3NF，因为：
- Time 和 Location 完全依赖于 (CourseID, InstructorID) 这个复合主键。
- StudentName 依赖于 StudentID。

##### BCNF分析
在BCNF中，我们要求每个决定因素（即能够唯一确定记录的属性集）都必须是超码（即包含候选键）。在上述3NF的关系模式中，如果我们有以下函数依赖：

1. (CourseID, InstructorID) → Time, Location
2. StudentID → StudentName

这个关系模式可能不满足BCNF，因为存在一个非候选键（CourseID）决定了另一个非候选键（InstructorID）。为了满足BCNF，我们需要将关系模式分解为两个关系模式：

**CourseSchedule(CourseID, InstructorID, Time, Location)**
- 这里，(CourseID, InstructorID) 是候选键，Time 和 Location 完全依赖于这个复合主键。

**StudentEnrollment(StudentID, StudentName, CourseID, InstructorID)**
- 这里，StudentID 是候选键，StudentName 依赖于 StudentID，而 CourseID 和 InstructorID 作为外键，与 CourseSchedule 表关联。

通过这样的设计，我们消除了非候选键对候选键的函数依赖，满足了BCNF的要求。这种设计有助于减少数据冗余，避免更新异常、插入异常和删除异常。

### 规范化过程
规范化过程是数据库设计中的一个重要步骤，旨在通过消除不合适的函数依赖来优化数据存储结构，减少数据冗余，提高数据完整性和一致性。以下是规范化过程的详细解释：

#### 1NF（第一范式）到2NF（第二范式）
- **目标**：消除非主属性对候选关键字的部分函数依赖。
- **方法**：确保所有非主属性完全依赖于整个主键，而不是主键的一部分。这通常涉及到分解表，使得每个表中的每个字段都只依赖于主键。
- **示例**：如果有一个包含学生信息和课程成绩的表，其中学生ID是主键的一部分，那么成绩应该完全依赖于学生ID，而不是其他任何非主属性。

#### 2NF（第二范式）到3NF（第三范式）
- **目标**：消除非主属性对候选关键字的传递函数依赖。
- **方法**：确保非主属性不依赖于其他非主属性。这意味着如果存在一个非主属性依赖于另一个非主属性，那么这两个属性应该被分离到不同的表中。
- **示例**：如果有一个包含学生、课程和教师信息的表，其中学生选课信息依赖于课程，而课程又依赖于教师，那么应该将课程和教师信息分离到不同的表中。

#### 3NF（第三范式）到BCNF（Boyce-Codd Normal Form）
- **目标**：消除主属性对候选关键字的部分和传递函数依赖。
- **方法**：确保每个决定因素（即能够唯一确定记录的属性集）都必须是超码（即包含候选键）。这涉及到分解表，使得每个表中的每个决定因素都包含候选键。
- **示例**：如果有一个包含课程、教师和时间信息的表，其中课程ID和教师ID共同决定时间，那么应该将课程和教师信息分离到不同的表中，以消除这种传递依赖。

#### 规范化的基本思想
规范化的基本思想是通过逐步消除不合适的函数依赖，使数据库中的各个关系模式达到某种程度的分离。这种分离有助于：
- **减少数据冗余**：通过消除重复数据，减少存储空间的浪费。
- **避免更新异常**：确保数据的一致性，避免因更新操作导致的数据不一致问题。
- **防止插入和删除异常**：确保即使在数据不完整的情况下，也能正确地插入和删除数据。

规范化是一个迭代过程，可能需要多次调整和优化。在实际应用中，设计者需要根据业务需求和性能考虑来决定规范化的程度。过度规范化可能会影响查询性能，因此需要在减少冗余和保持性能之间找到平衡。

以下是一张表格，展示了不同范式的定义、目的以及它们之间的区别：

| 范式 | 定义 | 目的 | 区别 |
|------|------|------|------|
| 1NF  | 表中的每一列都是不可分割的基本数据项，没有重复的组。 | 确保数据的原子性，避免数据冗余。 | 1NF 是规范化的起点，所有数据都存储在关系表中，没有数组或多重值。 |
| 2NF  | 在满足1NF的基础上，非主属性完全依赖于主键，没有部分依赖。 | 消除部分依赖，进一步减少数据冗余。 | 2NF 消除了非主属性对主键的部分依赖，但可能还存在传递依赖。 |
| 3NF  | 在满足2NF的基础上，非主属性不依赖于其他非主属性，消除了传递依赖。 | 消除传递依赖，减少数据冗余，防止更新异常。 | 3NF 消除了非主属性之间的传递依赖，但可能还存在主属性对候选键的部分和传递依赖。 |
| BCNF | 在满足3NF的基础上，每个决定因素都包含候选键，消除了主属性的部分和传递依赖。 | 消除所有不合适的函数依赖，包括主属性对候选键的部分和传递依赖。 | BCNF 是3NF的加强版，它要求每个函数依赖的左部都是超码，从而消除了所有部分和传递依赖。 |

#### 各个范式的目的
- **1NF** 的目的是确保数据的原子性，即每个字段都不可再分，这是规范化的基础。
- **2NF** 的目的是在1NF的基础上，通过消除部分依赖，进一步减少数据冗余，提高数据的一致性。
- **3NF** 的目的是在2NF的基础上，通过消除传递依赖，减少数据冗余，防止更新异常，提高数据的完整性。
- **BCNF** 的目的是在3NF的基础上，通过消除所有不合适的函数依赖，包括主属性对候选键的部分和传递依赖，达到最高的规范化程度。

#### 区别
- **1NF** 与 **2NF** 的主要区别在于是否消除了部分依赖。
- **2NF** 与 **3NF** 的主要区别在于是否消除了传递依赖。
- **3NF** 与 **BCNF** 的主要区别在于是否消除了主属性对候选键的部分和传递依赖。

规范化是一个逐步的过程，每个范式都是前一个范式的基础上的进一步优化。在实际的数据库设计中，根据业务需求和性能考虑，设计者可能会选择适当的规范化程度。

### 模式的分解
模式分解（Schema Decomposition）是数据库设计中规范化过程的一个重要步骤，它涉及到将一个或多个关系模式（表）分解成更小的、更规范的子模式（表），以消除数据冗余、更新异常、插入异常和删除异常。模式分解的目的是为了提高数据库的完整性、一致性和效率。以下是模式分解的一些关键点：

1. **消除冗余**：通过分解，可以消除存储在多个表中的重复数据，减少数据冗余。

2. **规范化**：模式分解有助于将数据库表规范化到更高的范式，如1NF、2NF、3NF或BCNF，这有助于提高数据的一致性和减少异常。

3. **减少异常**：通过分解，可以减少或消除更新、插入和删除异常。例如，如果一个信息在多个地方被复制，更新时可能会遗漏某些地方，导致数据不一致。

4. **提高性能**：在某些情况下，适当的分解可以提高数据库的查询性能，因为更小的表可以更快地被索引和搜索。

5. **增强灵活性**：分解后的模式可以更灵活地应对变化，因为对一个表的修改不太可能影响到其他表。

6. **保持依赖**：在分解过程中，需要确保原始模式中的函数依赖在分解后的模式中仍然得到保持。这通常通过在分解后的表之间建立外键约束来实现。

#### 模式分解的策略
1. **无损连接分解**：确保分解后的模式可以通过自然连接（Natural Join）无损地重构回原始模式。这意味着分解不应该丢失任何信息。

2. **依赖保持分解**：在分解过程中，需要保持原始模式中的所有函数依赖。这通常通过在分解后的表中引入外键来实现。

3. **减少依赖**：在分解时，目标是减少或消除不合适的函数依赖，如部分依赖和传递依赖。

#### 关系模式分解的策略
关系模式分解的标准是确保分解过程既符合规范化的要求，又能够保持数据的完整性和一致性。以下是关系模式分解时应遵循的一些关键标准：

1. **无损连接（Lossless Join）**：
   - 分解后的模式应该能够通过自然连接（Natural Join）无损地重构回原始模式。这意味着分解过程中不能丢失任何信息。

2. **依赖保持（Dependency Preservation）**：
   - 分解后的模式应该保持原始模式中的所有函数依赖。这确保了数据的完整性和一致性。

3. **减少冗余（Redundancy Reduction）**：
   - 分解应该旨在减少数据冗余，从而降低数据维护的复杂性和提高数据的一致性。

4. **消除异常（Anomaly Elimination）**：
   - 分解应该消除插入、更新和删除异常，这些异常可能导致数据不一致或丢失。

5. **提高性能（Performance Improvement）**：
   - 在某些情况下，分解可以提高数据库的查询性能，因为更小的表可以更快地被索引和搜索。

6. **增强灵活性（Enhanced Flexibility）**：
   - 分解后的模式应该更灵活地应对变化，因为对一个表的修改不太可能影响到其他表。

7. **保持键的完整性（Key Integrity Preservation）**：
   - 分解过程中，原始模式的候选键和主键应该在分解后的模式中得到保持。

8. **避免不必要的复杂性（Avoid Unnecessary Complexity）**：
   - 分解应该避免过度复杂化数据库结构，这可能会导致性能下降和维护困难。

9. **考虑业务需求（Business Requirement Consideration）**：
   - 分解应该考虑到业务需求和查询模式，以确保分解后的模式能够支持常见的业务操作。

10. **可扩展性（Scalability）**：
    - 分解应该考虑到数据库的可扩展性，确保随着数据量的增长，数据库的性能不会受到太大影响。

在实际的数据库设计中，设计者需要根据这些标准来决定是否进行分解以及如何进行分解。通常，这涉及到在减少数据冗余和保持查询性能之间找到平衡。


#### 示例
假设有一个学生选课系统，原始模式可能包含以下字段：学生ID、学生姓名、课程名称、课程学分。这个模式可能存在数据冗余，因为学生姓名可能会在多个课程记录中重复。通过分解，我们可以创建两个表：

- 学生表（StudentID, StudentName）
- 选课表（StudentID, CourseName, CourseCredits）

这样的分解减少了数据冗余，并且可以更容易地维护数据的一致性。如果学生姓名发生变化，只需要在学生表中更新一次，而不是在多个选课记录中更新。



