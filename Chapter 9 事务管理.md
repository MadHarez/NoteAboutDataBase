## 事务事务与并发调度
### 事务的概念
- **事务定义**
	- 事务是由一系列操作序列构成的程序执行单元，这些操作要么都做，要么都不做，是一个不可分割的工作单位。例如银行转帐。
	- **SQL中事务的定义**
		- 事务以Begin transaction开始，以Commit或 Rollback结束
		- Commit表示提交，事务正常结束
		- Rollback表示事务非正常结束，撤消事务已做的操作，回滚到事务开始时状态
		- 相关示例：
		- 银行转帐：事务T从A帐户过户50￥到B帐户
			T：	read(A);
				A := A – 50;
				write(A);
				read(B);
				B := B + 50;
				write(B);
				read(X)：从数据库传送数据项X到事务的工作区中
				write(X)：从事务的工作区中将数据项X写回数据库
- **事务特性（ACID）**
	- **原子性(Atomicity)**
		- 事务中包含的所有操作要么全做，要么全不做。
		- 原子性由恢复机制实现。
	- **一致性(Consistency)**
		- 事务的隔离执行必须保证数据库的一致性。
		- 事务开始前，数据库处于一致性的状态；事务结束后，数据库必须仍处于一致性状态。
		- 数据库的一致性状态由用户来负责，由并发控制机制实现。
		- 如银行转帐，转帐前后两个帐户金额之和应保持不变。
	- **隔离性(Isolation)**
		- 系统必须保证事务不受其它并发执行事务的影响。
		- 对任何一对事务T1，T2，在T1看来，T2要么在T1开始之前已经结束，要么在T1完成之后再开始执行。
		- 隔离性通过并发控制机制实现。
	- **持久性(Durability)**
		- 一个事务一旦提交之后，它对数据库的影响必须是永久的
		- 系统发生故障不能改变事务的持久性
		- 持久性通过恢复机制实现
- ![[Status Of Affairs.png]]
### 事务调度
#### 事务的调度
- **事务的执行顺序称为一个调度，表示事务的指令在系统中执行的时间顺序**
- **一组事务的调度必须保证**
	- 包含了所有事务的操作指令
	- 一个事务中指令的顺序必须保持不变
- **串行调度**
	- 在串行调度中，属于同一事务的指令紧挨在一起
	- 对于有n个事务的事务组，可以有n！个有效调度
- **并行调度**
	- 在并行调度中，来自不同事务的指令可以交叉执行
	- 当并行调度等价于某个串行调度时，则称它是正确的
#### 并行 Vs 串行
- **基本比较**
	- 并行事务会破坏数据库的一致性
	- 串行事务效率低
- **并行的优点**
	- 一个事务由不同的步骤组成，所涉及的系统资源也不同。这些步骤可以并发执行，以提高系统的吞吐量
	- 系统中存在着周期不等的各种事务，串行会导致难于预测的时延。如果各个事务所涉及的是数据库的不同部分，采用并发会减少平均响应时间
- **核心问题**
	- 在保证一致性的前提下最大限度地提高并发度
- ![[Eg for transaction execution.png]]
### 并发调度
- **并发调度事务中可能出现的问题**
	- **丢失更新**
	- **脏读（Dirty Read）**
	- **不可重复读（Unrepeatable Read）**
	- **幻读（Phantom Read）**
#### 丢失更新
- **定义**
	- 两个事务T1和T2读入同一数据并修改，T2提交的结果破坏了T1提交的结果，导致T1的修改丢失
	- 丢失更新问题是指在数据库并发事务中，两个或多个事务同时对同一数据进行修改，导致某些事务的更新被其他事务所覆盖的现象。这种情况通常发生在没有适当的锁定机制或隔离级别设置不当的情况下。丢失更新主要分为两种类型：

1. **第一类丢失更新（回滚丢失，Lost Update）**：一个事务在另一个事务提交后撤销（回滚），导致覆盖了已经提交的更新数据。这种情况下，SQL标准中未定义此现象，所有数据库都已解决了第一类丢失更新的问题。
    
2. **第二类丢失更新（覆盖丢失/两次更新问题，Second Lost Update）**：一个事务覆盖了另一个已经提交的事务的更新数据，造成后者的更新丢失。这和不可重复读本质上是同一类并发问题，通常将它看成不可重复读的特例。
- **示例**
- ![[Drop n Update.png]]
#### 脏读（Dirty Read）
- 脏读是指在一个事务中读取到另一个未提交事务的数据。如果另一个事务回滚了，那么读取到的数据实际上是无效的。脏读发生在读未提交（Read Uncommitted）隔离级别下，即事务可以读取到其他事务未提交的数据
- **示例**：
	- 事务A读取到事务B刚刚插入的数据。
	- 事务B回滚，数据被删除。
	- 事务A读取到的数据是脏数据，因为它实际上并不存在。数据，然后使用了这个数据。
#### 不可重复读（Unrepeatable Read）
- 不可重复读是指在一个事务中多次读取同一数据集合，由于其他事务的修改，导致读取到的数据不一致。不可重复读发生在读已提交（Read Committed）隔离级别下，即事务只能读取到其他事务提交后的数据。
	- **示例**：
		- 事务A读取到某个数据项的值。
		- 事务B更新了这个数据项的值并提交。
		- 事务A再次读取同一个数据项，发现值已经改变。
#### 幻读（Phantom Read）
- 幻读是指在一个事务中多次执行查询，由于其他事务的插入或删除操作，导致读取到的记录数量不一致。幻读发生在可重复读（Repeatable Read）隔离级别下，即事务可以重复读取到相同的数据集合，但是可能会遇到幻读问题。
	- **示例**：
	    - 事务A查询满足某个条件的所有记录。
	    - 事务B插入了一条满足该条件的新记录并提交。
	    - 事务A再次执行相同的查询，发现多了一条新记录。
	- ![[Unrepeatable Read.png]]
- **并行调度的可串行化**
	- **并发调度的可串行性**
		- 可串行化的调度：多个事务的并发执行是正确的，当且仅当其结果与按某一次序串行地执行它们时的结果相同。
		- 正确调度：一个给定的并发调度，当且仅当它是可串行化的。
- ![[Different scheduling of parallel transactions.png]]
	- **指令的顺序**
		- 考虑一个调度S中的两条连续指令（仅限于read与 write操作）Ii与Ij，分别属于事务Ti与Tj
			①${I_i}$ = read(Q), ${I_j}$= read(Q);
			②${I_i}$= read(Q), ${I_j}$ = write(Q);
			③${I_i}$= write(Q), ${I_j}$= read(Q);
			④${I_i}$= write(Q), ${I_j}$ = write(Q);
			在① 情况下，${I_i}$与${I_j}$的次序无关紧要。其余情况下，Ii与Ij的次序不同，其执行结果也不同，数据库最终状态也不同
	- **冲突指令**
		- 当两条指令是不同事务在相同数据项上的操作，并且其中至少有一个是write指令时，则称这两条指令是冲突的
		- 如在②、③、④情况下，Ii与Ij 是冲突的
		- 非冲突指令交换次序不会影响调度的最终结果
	- **冲突等价**
		- 如果调度S可以经过一系列非冲突指令交换转换成调度S‘，则称调度S与S’是冲突等价的
	- **冲突可串行化**
		- 当一个调度S与一个串行调度冲突等价时，则称该调度是冲突可串行化的
		- 如并行调度3是冲突可串行化的
	- **示例**
	- ![[Serialization of parallel scheduling.png]]
#### 封锁机制
- **所谓并发控制就是要用正确的方式并发操作避免造成数据的不一致性，使一个用户事务的执行不受其他事务的干扰**
- **另一方面，对数据库的应用有时允许某些不一致性，例如，有些统计工作涉及数据量很大，读到一些脏数据对统计精度没什么影响，这时可以降低对一致性的要求以减少系统开销**
- **并发控制的主要方式使采用封锁机制**

##### 封锁
**事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁。加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其他的事务不能更新此数据对象。**

##### 共享锁（读锁，S锁）
共享锁（Shared Lock），也称为读锁或S锁，是一种允许多个进程或线程同时访问同一资源的锁定机制，但只允许读取操作，不允许写入操作。这种锁通常用于数据读取操作，因为它允许多个进程或线程并发地读取数据，从而提高系统的吞吐量和性能。

共享锁的主要特点包括：

1. **共享性**：多个进程或线程可以同时持有共享锁，只要它们不进行写入操作。
2. **写入阻塞**：如果一个进程或线程持有共享锁，那么任何试图获取排它锁（写锁）的进程或线程都会被阻塞，直到所有共享锁都被释放。
3. **升级困难**：从共享锁升级到排它锁通常是一个复杂的过程，因为必须等待所有持有共享锁的进程或线程释放它们的锁，这可能会导致性能问题。
4. **降级容易**：从排它锁降级到共享锁相对容易，因为只需要释放排它锁即可。

在数据库系统中，共享锁用于读取操作，以允许多个事务同时查询数据，而不会互相干扰。例如，当一个事务需要读取表中的一行数据时，它可以对该行数据加共享锁，直到事务完成。

在编程中，不同的编程语言和框架提供了不同的机制来实现共享锁，例如读写锁（Read-Write Lock）等。正确地使用这些机制可以有效地平衡数据的并发访问和数据的一致性。

##### 排它锁（写锁，X锁）
排它锁（Exclusive Lock），也称为写锁或X锁，是一种锁定机制，用于控制对共享资源的访问。当一个进程或线程获得排它锁时，它可以独占地访问被锁定的资源，而其他任何进程或线程都不能同时访问该资源。这种锁通常用于数据写入操作，因为它可以防止多个进程或线程同时修改数据，从而避免数据不一致的问题。

排它锁的主要特点包括：

1. **独占性**：一个资源在同一时间只能被一个进程或线程锁定。
2. **不可重入性**：一个已经持有排它锁的进程或线程不能再次请求该锁，直到它释放锁。
3. **阻塞性**：如果资源已经被锁定，任何尝试获取该锁的进程或线程都会被阻塞，直到锁被释放。
4. **死锁风险**：如果不正确地使用排它锁，可能会导致死锁，即两个或多个进程或线程相互等待对方释放锁，从而陷入僵局。

在数据库系统中，排它锁通常用于更新操作，以确保数据的完整性。例如，当一个事务需要更新表中的一行数据时，它会对该行数据加排它锁，直到事务完成并提交或回滚，锁才会被释放。

在编程中，不同的编程语言和框架提供了不同的机制来实现排它锁，例如互斥锁（Mutex）、临界区（Critical Section）和信号量（Semaphore）等。正确地使用这些机制对于保证程序的并发安全至关重要。

 #### 封锁协议
- **封锁协议**
	- 对数据对象加锁时，还需要约定一些规则，称这些规则为封锁协议。
- **一级封锁协议**
	- 事务T在修改数据之前必须先对其加X锁，直到事务结束才释放。
- **二级封锁协议**
	- 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，读完后即可释放S锁。
- **三级封锁协议**
	- 一级封锁协议加上事务T在读取数据R之前必须先对其加S锁，直到事务结束才释放。

#### 活锁和死锁
##### 死锁（Deadlock）

死锁是指两个或多个进程在执行过程中，因争夺资源而造成的一种僵局。当每个进程都持有一些资源，并且请求其他进程持有的资源时，如果没有适当的机制来解决这种互相等待的状态，那么这些进程就会永远阻塞下去，无法继续执行。

**死锁的四个必要条件**：

1. **互斥条件**：资源不能被多个进程同时使用。
2. **占有和等待条件**：进程在占有至少一个资源的同时，等待获取其他进程占有的资源。
3. **不可抢占条件**：资源只能由占有它的进程自愿释放。
4. **循环等待条件**：存在一个进程-资源的循环链，链中的每个进程都在等待下一个进程所占有的资源。

**解决死锁的方法**：

- **预防**：破坏死锁的一个或多个必要条件。
- **避免**：使用算法动态避免死锁的发生。
- **检测和恢复**：允许死锁发生，但系统能够检测到死锁并采取措施恢复。

##### 活锁（Livelock）

活锁是指两个或多个进程在尝试执行某个操作时，由于不断地改变策略来响应其他进程，导致它们永远无法实际完成操作的状态。在活锁中，并没有资源被永久占用，也没有进程被永久阻塞，但进程们却无法取得进展。

**活锁的例子**：

- **交通堵塞**：两个司机在一条狭窄的道路上相遇，每个司机都礼貌地后退给对方让路，结果两人不断地来回移动，却始终无法通过。

**解决活锁的方法**：

- **随机化**：引入随机性，使得进程在尝试获取资源时不会总是采取相同的策略。
- **超时**：设置超时时间，超过一定时间后改变策略。
- **优先级调整**：根据某种策略调整进程的优先级，以减少冲突。

活锁和死锁都是并发编程中需要避免的问题，它们都会导致系统资源的浪费和性能下降。正确地设计并发控制机制是避免这些问题的关键。

##### 二段锁协议
两段锁协议（Two-Phase Locking Protocol，简称2PL）是一种并发控制机制，用于确保数据库事务的隔离性和一致性。它通过将事务的锁定操作分为两个阶段来避免数据不一致和并发冲突的问题。以下是两段锁协议的详细解释：

1. **加锁阶段（Growing Phase）**：在这个阶段，事务可以获取锁，并且在获取锁之后可以继续请求新的锁。事务在这个阶段可以并发执行，并且可以同时获取多个锁。但是，一旦一个事务释放了一个锁，它就不能再获取新的锁，因为它已经进入了解锁阶段。
    
2. **解锁阶段（Shrinking Phase）**：在这个阶段，事务可以释放锁，但不能再获取新的锁。一旦事务释放了一个锁，该锁就可以被其他事务获取。这个阶段的目的是确保事务在释放锁之后不会再访问数据，从而避免数据不一致的问题。
    
3. **预防死锁**：两段锁协议通过严格的锁定顺序来预防死锁的发生。事务在获取锁之前，必须先获得所有需要的锁，而不是等待其他事务释放锁。这样可以避免循环等待条件，从而避免死锁的发生。
    
4. **一致性**：两段锁协议保证了事务之间的一致性。一个事务在释放锁之前，必须确保它已经完成了所有的操作，并且对数据进行了正确的更新。这样可以确保其他事务在获取锁之后，读取到的数据是一致的。
    
5. **隔离性**：两段锁协议保证了事务之间的隔离性。事务在获取锁之后，其他事务不能对相同的数据进行读取或写入操作，从而避免了并发冲突的问题。这种隔离性可以确保事务之间的操作互不干扰，从而保证了数据的一致性和完整性。
    

两段锁协议是可串行化的充分条件，但不是必要条件。如果所有事务都遵循两段锁协议，那么它们的并发调度是可串行化的，这意味着并发执行的结果与某个串行执行的结果相同，从而保证了事务的隔离性和数据的一致性。然而，两段锁协议也可能导致性能问题，因为它限制了事务在某些情况下的并发执行

**示例：**
假设我们有一个简单的银行账户转账场景，其中涉及到两个账户：账户A和账户B。我们要从一个账户（账户A）向另一个账户（账户B）转账一定金额。这个过程需要确保数据的一致性和隔离性，以防止诸如脏读、不可重复读或丢失更新等问题。

 **事务1：从账户A向账户B转账**

1. **加锁阶段**：
    
    - 事务开始。
    - 事务请求并获取账户A的排他锁（X锁），以进行余额读取和扣款操作。
    - 事务请求并获取账户B的排他锁（X锁），以进行余额读取和加款操作。
2. **操作阶段**：
    
    - 事务读取账户A的当前余额。
    - 事务从账户A的余额中扣除转账金额。
    - 事务读取账户B的当前余额。
    - 事务将转账金额加到账户B的余额中。
3. **解锁阶段**：
    
    - 事务提交（或在出错时回滚）。
    - 事务释放账户A的排他锁（X锁）。
    - 事务释放账户B的排他锁（X锁）。
```
BEGIN;  -- 事务开始
LOCK A;  -- 获取账户A的排他锁
LOCK B;  -- 获取账户B的排他锁
READ A;  -- 读取账户A的余额
DEDUCT A;  -- 从账户A扣除转账金额
READ B;  -- 读取账户B的余额
ADD B;  -- 将转账金额加到账户B
COMMIT;  -- 提交事务，释放所有锁
```
### 事务和事务日志
- **一个事务包括一个或许多个操作的集合，可以是：插入、修改、删除等命令或更复杂的操作。**
-  **事务的特性**
	- 原子性（Atomicity）
		一个事务中的操作是不可分割的，要么全部执行成功，要么全部不执行
	- 一致性（Consistency）
		事务执行的前后，数据库中的数据都处于一致性状态。
	- 独立性（Isolation）
		事务之间不能互相干扰。
	- 永久性（Durability）
		事务一旦执行成功，则对数据库的影响是永久的。
- **如果提交了一个事务，SQL Server就会在事务日志中记录所有有关该事务的信息。**
- **为一个事务记录的数据总量取决于以下几个方面：**
	- 更改的数据量
	- 受影响的索引量
	- 作为事务的结果，必须分配或释放的页的数量
#### 事务日志条目
- **开始条目**
- **记录数据修改**
- **进行数据修改**
- **提交事务**
- **将日志页转存于磁盘**
##### 事务日志条目示例
- 操作：更新一条记录，日志文件将增加：
	- **一个数据删除记录，包括原有行中所有数据**
	- **一个数据插入记录，包括修改后行中所有数据**
	- **一个受该事务影响的每个索引的索引删除记录**
	- **一个受该事务影响的每个索引的索引插入记录**
	- **一个用于每个新数据或索引页的页分配记录，和一个用于每个释放数据或索引页的页释放记录**
**事务开始**
- `BEGIN;`  
  事务开始。
**数据库操作**
- `START TRANSACTION;`  
  开始一个新的事务。
- `SELECT account_balance FROM accounts WHERE account_id = 123;`  
  查询账户ID为123的当前余额。
- `UPDATE accounts SET account_balance = account_balance - 100 WHERE account_id = 123;`  
  从账户ID为123的余额中扣除100元。
- `SELECT account_balance FROM accounts WHERE account_id = 456;`  
  查询账户ID为456的当前余额。
- `UPDATE accounts SET account_balance = account_balance + 100 WHERE account_id = 456;`  
  向账户ID为456的余额中增加100元。
 **事务结束**
- `COMMIT;`  
  提交事务，所有更改被保存到数据库中，事务日志记录这些更改。
## 数据库恢复技术
### 数据库恢复概述
#### 计算机系统中不可避免的问题
- **硬件的故障**
	- **硬件故障可能导致系统突然中断，影响数据的完整性和可用性。**
 - **软件的错误**
	- **软件缺陷可能引起程序异常，导致数据不一致或丢失。**
- **操作员的失误**
	- **人为操作错误可能误删除或修改重要数据。**
- **恶意的破坏**
	- **恶意攻击或破坏可能导致数据泄露或服务不可用。**
#### 故障的影响
- **轻微情况：** 造成运行事务非正常中断，影响数据库中数据的正确性。
- **严重情况：** 破坏数据库，使数据库中全部或部分数据丢失。
#### 数据库管理系统（恢复子系统）
- **把数据库从错误状态恢复到某一已知的正确状态（亦称为一致状态或完整状态）。这就是数据库的恢复，确保数据的持久性和一致性。**
#### 故障的种类
- **事务内部的故障**
	- 预期的
		- 可通过事务程序本身发现
	- 非预期的
		- 不能由应用程序处理的，如运算溢出、并行事务发生死锁而被选中撤销该事务等
- **系统故障（软故障，Soft Crash）**
	- 指造成系统停止运转的任何事件，使得统要重新启动
	- 中央处理器故障、操作系统故障、突然停电
- **介质故障（硬故障，Hard Crash）**
	- 外存故障，如磁盘的磁头碰撞，瞬时的强磁场干扰
- **计算机病毒**
**总结，对数据库的影响可能性**
- 数据库本身被破坏
- 数据库没有破坏，但数据可能不正确，因为事务的运行被中止所造成
#### 恢复的基本原理
- **恢复的基本原理：冗余**
	- 数据库中任何一部分的数据，可以根据存储在系统别处的冗余数据来重建
- **恢复的最常用方法：**
	- 转储和登记日志文件
- **恢复的基本原理涉及以下几个关键方面：**
  - **数据冗余**：通过备份和日志记录，创建数据的额外副本，以便在原始数据损坏或丢失时恢复。
  - **事务日志**：记录事务对数据库所做的所有更改，以便可以重放或撤销这些更改以恢复到一致状态。
  - **一致性检查点**：在特定时间点捕捉数据库的状态，以便在发生故障时可以从最近的检查点恢复。
  - **故障检测**：能够识别硬件、软件或人为错误导致的故障。
  - **错误隔离**：确定错误的影响范围，并限制其对数据库其他部分的影响。
  - **数据重组**：在检测到不一致时，使用备份和日志重新构建数据以恢复到一致状态。
  - **前滚操作**：使用日志中的提交记录将数据库恢复到故障发生时的状态。
  - **回滚操作**：撤销未完成事务的更改，以确保数据库恢复到一致状态。
  - **介质修复**：修复或替换损坏的存储介质，以恢复数据的完整性。
  - **并发控制**：在恢复过程中管理对数据的并发访问，以防止进一步的不一致。
#### 恢复的实现技术
- **数据转储**
    - 后备副本或后援副本
    - 转储周期
    - 静态转储和动态转储
    - 海量转储和增量转储
  - **登记日志文件**
    - 日志文件的格式和内容
    - 记录为单位和数据块为单位
    - 日志文件的作用
    - 登记日志文件：“先写日志文件”的原则
- **检查点技术**：
  - 定期保存数据库的状态，以便快速恢复到最近的一致状态。
- **影子复制（Shadow Copy）**：
  - 创建数据的实时副本，不影响原始数据的使用。
- **事务隔离级别**：
  - 控制事务的可见性，以维护数据的一致性和完整性。
- **故障检测和恢复策略**：
  - 实施故障检测机制，并根据故障类型采取相应的恢复措施。
- **数据恢复算法**：
  - 使用算法如前滚和回滚操作，以恢复事务日志中的更改。
- **数据一致性检查**：
  - 定期检查数据的一致性，并修复任何不一致问题。
- **硬件冗余和故障转移**：
  - 使用RAID技术和故障转移机制来保护数据不受硬件故障的影响。
- **数据完整性约束**：
  - 通过约束和触发器确保数据的完整性，以便在发生错误时能够检测和恢复。
- **软件容错技术**：
  - 采用软件容错技术来检测和修复软件错误。
- **安全措施和入侵检测**：
  - 实施安全措施以防止恶意破坏，并使用入侵检测系统来识别和响应安全威胁。
##### 数据转储
- **转储**
  - DBA定期地将整个数据库复制到磁带或另一个磁盘上保存起来的过程
- **后备副本或后援副本：备用的数据文本**
- **静态转储**
  - 转储期间不允许（或不存在）对数据库进行任何存取、修改活动
- **动态转储**
	- 转储期间允许对数据库进行存取或修改
	- 即转储和用户事务可以并发执行
- **海量转储**
  - 每次转储全部数据库
- **增量转储**
  - 每次只转储上次转储后更新过的数据

- **静态转储**
	- 简单
	- 降低数据库的可用性
- **动态转储**
	- 转储结束时后援副本上的数据并不能保证正确有效
	- 示例：在转储期间的某时刻T1系统把数据A=100转储到了磁带上，而在时刻T2，某一事务对A进行了修改使A=200。转储结束，后援副本上的A已是过时的数据了。
	为此，必须把转储间各事务对数据库的修改活动登记下来，建立日志文件（log file）。这样，后援副本加上日志文件就能把数据库恢复到某一时刻
	的正确状态。
##### 登记日志文件
- **日志文件的格式和内容**
  - 日志文件通常包含事务开始、事务结束、数据修改等关键操作的记录。
  - 每条日志记录可能包括事务标识符、操作类型、操作前后的数据状态、时间戳等信息。

- **记录为单位和数据块为单位**
  - 日志记录可以基于单个记录（如行）或整个数据块。
  - 记录为单位的日志提供了更细粒度的恢复能力，但可能会产生更多的日志数据。
  - 数据块为单位的日志在处理大量数据修改时可能更高效，但在恢复时粒度较粗。

- **日志文件的作用**
  - **故障恢复**：在系统发生故障时，使用日志文件重放（前滚）或撤销（回滚）事务，以恢复到故障前的正确状态。
  - **一致性维护**：确保事务的原子性和持久性，即使在系统崩溃后也能保持数据的一致性。
  - **并发控制**：在某些情况下，日志文件也用于记录锁信息，帮助解决事务间的并发冲突。

- **登记日志文件：“先写日志文件”的原则**
  - 为了确保事务的持久性，数据库管理系统通常遵循“先写日志文件”的原则。
  - 在事务的任何修改操作实际应用到数据库之前，首先将这些操作记录到日志文件中。
  - 如果系统在事务提交前发生故障，日志文件可以用于重构事务并恢复数据。
  - 这种原则也称为Write-Ahead Logging (WAL)，是确保数据恢复和一致性的关键技术。
##### 事务恢复
- 利用日志文件恢复事务的过程分为二步：
    - 从头扫描日志文件，找出哪些事务在故障发生时已经结束（这些事务有BEGIN TRANSACTION和COMMIT记录），哪些事务尚未结束（这些事务有BEGIN TRANSACTION记录，无COMMIT记录）。
    - 对尚未结束的事务进行撤销（也称UNDO）处理，对已经结束的事务进行重做（REDO）处理。
- UNDO处理的方法：
  - 反向扫描日志文件，对每个UNDO事务的更新操作执行反操作。
- REDO处理的方法：
  - 正向扫描日志文件，重新执行登记的操作。
- 利用转储和日志文件可以有效地恢复数据库。
**转储和恢复**
![[Normal.png]]
![[Recover.png]]
**利用日志文件**
![[Normal1.png]]
![[Normal1.png]]
##### 恢复策略
- **事务故障的恢复**
	- **发生后由系统自动完成**
- **系统故障的恢复**
	- **重启系统，由系统自动完成**
- **介质故障的恢复**
	- **由DBA重装数据库**
- **具有检查点的恢复技术**
- **数据库镜像**
`BEGIN TRANSACTION
	读账户甲的余额BALANCE；
		`BALANCE=BALANCE-AMOUNT；`（Amount为转账金额）
		   `IF (BALANCE<0) THEN`
			{   打印‘金额不足，不能转帐’；
		          `ROLLBACK；`（撤销刚才的修改，恢复事务）}
		   `ELSE`
		{    读账户乙的余额BALANCE1；`BALANCE1=BALANCE1+AMOUNT；`
			      写回BALANCE1；
			      COMMIT；}`
##### 事务内部的故障
- 事务内部更多的故障是非预期的，是不能由应用程序处理的。这类非预期的故障称为事务故障。如:
	- 运算溢出；
	- 并发事务发生死锁而被选中撤消该事务、违反了某些完整性限制等。
- 事务故障意味着：
	- 事务没有达到预期的终点（COMMIT或者显式的ROLLBACK）；
	- 数据库可能处于不正确状态。
##### 事务撤销（UNDO）
- **恢复程序要在不影响其它事务运行的情况下:**
	- 强行回滚（ROLLBACK）该事务，即撤消该事务已经作出的任何对数据库的修改，使得该事务好象根本没有启动一样。
- **这类恢复操作称为事务撤消（UNDO）。**
##### 事务故障的恢复
**事务故障的恢复是由系统自动完成的，对用户是透明的。系统的恢复步骤是：**
1. **反向扫描文件日志（即从最后向前扫描日志文件），查找该事务的更新操作。**
2. **对该事务的更新操作执行逆操作。即将日志记录中“更新前的值”写入数据库。**
3. **继续反向扫描日志文件，查找该事务的其他更新操作，并做同样处理。** 
4. **如此处理下去，直至读到此事务的开始标记。**
##### 系统故障
- **系统故障是指造成系统停止运转的任何事件，使得系统要重新启动。例如**
	- 特定类型的硬件错误（CPU故障）;
	- 操作系统故障;
	- DBMS代码错误
	- 突然停电等等。
- **为保证数据一致性，恢复子系统必须在系统重新启动时:**
	- 让所有非正常终止的事务回滚，强行撤消（UNDO）所有未完成事务;
	- 重做（REDO）所有已提交的事务，以将数据库真正恢复到一致状态。
#### 介质故障的恢复
- **发生介质故障后，磁盘上的物理数据和日志文件被破坏，这是最严重的一种故障，恢复方法是重装数据库，然后重做已完成的事务。**
- **介质故障的恢复需要DBA介入。DBA需要重装最近转储的数据库副本和有关的各日志文件副本，然后执行系统提供的恢复命令即可，具体的恢复操作由DBMS完成。** 
##### 介质故障的恢复步骤
- **装入最新的数据库后备副本（离故障发生时刻最近的转储副本），使数据库恢复到最近一次转储时的一致性状态。** 
- **对于动态转储的数据库副本，还须同时装入转储开始时刻的日志文件副本，利用恢复系统故障的方法（即REDO+UNDO），才能将数据库恢复到一致性状态。** 
- **装入相应的日志文件副本（转储结束时刻的日志文件副本），重做已完成的事务。**
##### 具有检查点的恢复技术
- **利用日志技术进行数据库恢复时，需要检查所有日志记录。存在两个问题：**
	- **搜索整个日志将耗费大量的时间。**
	- **需要REDO处理很多已经将操作结果写到数据库中的操作，浪费了大量时间。**
- **具有检查点的恢复技术：在日志文件中增加一类新的记录--检查点记录（checkpoint），增加一个重新开始文件，并让恢复子系统在登录日志文件期间动态地维护日志。**
**检查点记录的内容**
- **检查点记录的内容包括：** 
	- **建立检查点时刻所有正在执行的事务清单。**
	- **这些事务最近一个日志记录的地址。**
- **重新开始文件用来记录各个检查点记录在日志文件中的地址。**
- **重新开始文件和日志文件结构。**
##### 动态维护日志文件
- 动态维护日志文件的方法是，周期性地执行如下操作：建立检查点，保存数据库状态。
- 具体步骤是： 
	1. 将当前日志缓冲中的所有日志记录写入磁盘的日志文件上。 
	2. 在日志文件中写入一个检查点记录。 
	3. 将当前数据缓冲的所有数据记录写入磁盘的数据库中。 
	4. 把检查点记录在日志文件中的地址写入一个重新开始文件。
- 恢复子系统可以定期或不定期地建立检查点保存数据库状态。
##### 用检查点方法进行恢复的步骤
**系统使用检查点方法进行恢复的步骤是：**
1. **从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录。** 
2. **由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST。**
	- **建立两个事务队列: UNDO-LIST；REDO-LIST。把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空。** 
3. **从检查点开始正向扫描日志文件** 
	- **如有新开始的事务Ti，把Ti暂时放入UNDO-LIST队列；如有提交的事务Tj，把Tj从UNDO-LIST队列移到REDO-LIST队列；** 
4. **对UNDO-LIST中的每个事务执行UNDO操作, 对REDO-LIST中的每个事务执行REDO操作** 
##### 数据库镜像
- **介质故障是对系统影响最为严重的一种故障。**
- **许多数据库管理系统提供了数据库镜像（Mirror）功能用于数据库恢复。即根据DBA的要求，自动把整个数据库或其中的关键数据复制到另一个磁盘上。**
- **DBMS自动保证镜像数据与主数据的一致性。**
- **一旦出现介质故障，可由镜像磁盘继续提供使用，同时DBMS自动利用镜像磁盘数据进行数据库的恢复，不需要关闭系统和重装数据库副本。**


### 补充部分
**关于[[#丢失更新]]的解决方案，可以采用以下几种策略：**
1. **悲观锁（Pessimistic Locking）**：通过数据库的锁机制来防止多个事务同时修改同一数据。在事务开始时，对涉及的数据行加锁，直到事务结束时才释放锁。这样可以确保在事务处理期间，其他事务不能同时修改同一条记录。例如，在MySQL中，可以使用`SELECT ... FOR UPDATE`语句来实现悲观锁。
    
2. **乐观锁（Optimistic Locking）**：乐观锁的基本思想是在更新数据时，先读取数据的版本号；更新时会判断版本号是否与读取时相同，若不同则表示数据已被修改，会拒绝当前更新。这通常通过在数据表中添加一个版本号字段来实现。如果更新时发现版本号不匹配，说明数据已经被其他事务修改，当前事务可以采取重试或者回滚等措施。
    
3. **调整数据库事务隔离级别**：通过提升数据库的事务隔离级别来减少并发事务对同一数据的访问冲突。例如，将隔离级别设置为`REPEATABLE READ`或`SERIALIZABLE`可以有效防止丢失更新问题。不过，提高隔离级别可能会降低数据库的并发性能。**
#### 乐观锁和悲观锁
##### 悲观锁（Pessimistic Locking）

**定义：** 悲观锁是一种数据库事务处理机制，它假设在事务中会发生数据冲突，因此在事务开始时就对数据进行锁定，以防止其他事务修改数据。

**特点：**

1. **锁定数据：** 在事务开始时，悲观锁会锁定涉及的数据行或表，确保在当前事务中数据不会被其他事务修改。
2. **减少冲突：** 通过锁定数据，悲观锁减少了事务间的冲突，因为其他事务不能修改被锁定的数据。
3. **适用于高冲突环境：** 在写操作频繁的场景下，悲观锁可以有效地保证数据的一致性。

**实现方式：**

- **行级锁：** 多数数据库管理系统（如MySQL的InnoDB引擎）支持行级锁，允许对单个数据行加锁。
- **表级锁：** 一些数据库（如MyISAM）使用表级锁，锁定整个表，阻止其他事务对表的读写操作。

**示例（MySQL）：**

```sql
BEGIN;
START TRANSACTION;
SELECT * FROM table_name WHERE condition FOR UPDATE;
-- 进行数据修改操作
COMMIT;
```

**缺点：**

- **降低并发性：** 锁定数据可能会导致其他事务长时间等待，从而降低数据库的并发性能。
- **死锁风险：** 悲观锁可能会引起死锁，需要通过事务回滚来解决。

##### 乐观锁（Optimistic Locking）

**定义：** 乐观锁是一种数据库事务处理机制，它假设在事务中数据冲突发生的概率较低，因此不会立即锁定数据，而是在提交更新时检查数据是否被其他事务修改过。

**特点：**

1. **无锁：** 乐观锁通常不会在事务开始时锁定数据，允许多个事务同时读取数据。
2. **版本控制：** 乐观锁通常使用版本号或时间戳来实现，通过检查版本号或时间戳来确定数据是否被修改。
3. **适用于低冲突环境：** 在读操作频繁且写操作较少的场景下，乐观锁可以提高数据库的并发性能。

**实现方式：**

- **版本号机制：** 在数据表中添加一个版本号字段，每次更新数据时，版本号增加。
- **时间戳机制：** 使用时间戳来记录数据的最后更新时间，更新时检查时间戳是否一致。

**示例（Java + JPA）：**

```java
@Entity
public class MyEntity {
  @Id
  private Long id;
  
  private String data;
  
  @Version
  private int version;
  
  // getters and setters
}

// 在更新数据时
MyEntity entity = em.find(MyEntity.class, id);
entity.setData("new data");
em.flush();
```

**缺点：**

- **更新失败：** 如果数据在事务中被其他事务修改，乐观锁可能会导致更新失败，需要重试或回滚事务。
- **增加复杂性：** 需要额外的版本控制逻辑，可能会增加应用程序的复杂性。

**总结：** 悲观锁和乐观锁各有优缺点，适用于不同的场景。悲观锁适合于写操作频繁、冲突率高的环境，而乐观锁适合于读操作频繁、冲突率低的环境。在实际应用中，选择哪种锁策略取决于具体的业务需求和系统设计。
















